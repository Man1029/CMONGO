// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cmongo/cmongoproto/cmongo.proto

#ifndef PROTOBUF_cmongo_2fcmongoproto_2fcmongo_2eproto__INCLUDED
#define PROTOBUF_cmongo_2fcmongoproto_2fcmongo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace cmongoproto {
class CommandContainerReq;
class CommandContainerReqDefaultTypeInternal;
extern CommandContainerReqDefaultTypeInternal _CommandContainerReq_default_instance_;
class CommandContainerRes;
class CommandContainerResDefaultTypeInternal;
extern CommandContainerResDefaultTypeInternal _CommandContainerRes_default_instance_;
class ConfigParam;
class ConfigParamDefaultTypeInternal;
extern ConfigParamDefaultTypeInternal _ConfigParam_default_instance_;
class CreateContainerReq;
class CreateContainerReqDefaultTypeInternal;
extern CreateContainerReqDefaultTypeInternal _CreateContainerReq_default_instance_;
class CreateContainerRes;
class CreateContainerResDefaultTypeInternal;
extern CreateContainerResDefaultTypeInternal _CreateContainerRes_default_instance_;
class DestroyContainerReq;
class DestroyContainerReqDefaultTypeInternal;
extern DestroyContainerReqDefaultTypeInternal _DestroyContainerReq_default_instance_;
class DestroyContainerRes;
class DestroyContainerResDefaultTypeInternal;
extern DestroyContainerResDefaultTypeInternal _DestroyContainerRes_default_instance_;
class DynamoProxyParam;
class DynamoProxyParamDefaultTypeInternal;
extern DynamoProxyParamDefaultTypeInternal _DynamoProxyParam_default_instance_;
class HeartBeatReq;
class HeartBeatReqDefaultTypeInternal;
extern HeartBeatReqDefaultTypeInternal _HeartBeatReq_default_instance_;
class HeartBeatRes;
class HeartBeatResDefaultTypeInternal;
extern HeartBeatResDefaultTypeInternal _HeartBeatRes_default_instance_;
class InfoContainerReq;
class InfoContainerReqDefaultTypeInternal;
extern InfoContainerReqDefaultTypeInternal _InfoContainerReq_default_instance_;
class InfoContainerRes;
class InfoContainerResDefaultTypeInternal;
extern InfoContainerResDefaultTypeInternal _InfoContainerRes_default_instance_;
class MongoDParam;
class MongoDParamDefaultTypeInternal;
extern MongoDParamDefaultTypeInternal _MongoDParam_default_instance_;
class MongoSParam;
class MongoSParamDefaultTypeInternal;
extern MongoSParamDefaultTypeInternal _MongoSParam_default_instance_;
class PingReq;
class PingReqDefaultTypeInternal;
extern PingReqDefaultTypeInternal _PingReq_default_instance_;
class PingRes;
class PingResDefaultTypeInternal;
extern PingResDefaultTypeInternal _PingRes_default_instance_;
class Proxy2Param;
class Proxy2ParamDefaultTypeInternal;
extern Proxy2ParamDefaultTypeInternal _Proxy2Param_default_instance_;
class ProxyParam;
class ProxyParamDefaultTypeInternal;
extern ProxyParamDefaultTypeInternal _ProxyParam_default_instance_;
class RSAddReq;
class RSAddReqDefaultTypeInternal;
extern RSAddReqDefaultTypeInternal _RSAddReq_default_instance_;
class RSAddRes;
class RSAddResDefaultTypeInternal;
extern RSAddResDefaultTypeInternal _RSAddRes_default_instance_;
class RSInitReq;
class RSInitReqDefaultTypeInternal;
extern RSInitReqDefaultTypeInternal _RSInitReq_default_instance_;
class RSInitRes;
class RSInitResDefaultTypeInternal;
extern RSInitResDefaultTypeInternal _RSInitRes_default_instance_;
class RSRemoveReq;
class RSRemoveReqDefaultTypeInternal;
extern RSRemoveReqDefaultTypeInternal _RSRemoveReq_default_instance_;
class RSRemoveRes;
class RSRemoveResDefaultTypeInternal;
extern RSRemoveResDefaultTypeInternal _RSRemoveRes_default_instance_;
class RSStatusReq;
class RSStatusReqDefaultTypeInternal;
extern RSStatusReqDefaultTypeInternal _RSStatusReq_default_instance_;
class RSStatusRes;
class RSStatusResDefaultTypeInternal;
extern RSStatusResDefaultTypeInternal _RSStatusRes_default_instance_;
class ReqHeader;
class ReqHeaderDefaultTypeInternal;
extern ReqHeaderDefaultTypeInternal _ReqHeader_default_instance_;
class ResHeader;
class ResHeaderDefaultTypeInternal;
extern ResHeaderDefaultTypeInternal _ResHeader_default_instance_;
class ResizeContainerReq;
class ResizeContainerReqDefaultTypeInternal;
extern ResizeContainerReqDefaultTypeInternal _ResizeContainerReq_default_instance_;
class ResizeContainerRes;
class ResizeContainerResDefaultTypeInternal;
extern ResizeContainerResDefaultTypeInternal _ResizeContainerRes_default_instance_;
class ResourceDesc;
class ResourceDescDefaultTypeInternal;
extern ResourceDescDefaultTypeInternal _ResourceDesc_default_instance_;
class StartContainerReq;
class StartContainerReqDefaultTypeInternal;
extern StartContainerReqDefaultTypeInternal _StartContainerReq_default_instance_;
class StartContainerRes;
class StartContainerResDefaultTypeInternal;
extern StartContainerResDefaultTypeInternal _StartContainerRes_default_instance_;
class StopContainerReq;
class StopContainerReqDefaultTypeInternal;
extern StopContainerReqDefaultTypeInternal _StopContainerReq_default_instance_;
class StopContainerRes;
class StopContainerResDefaultTypeInternal;
extern StopContainerResDefaultTypeInternal _StopContainerRes_default_instance_;
class UpdateContainerModuleReq;
class UpdateContainerModuleReqDefaultTypeInternal;
extern UpdateContainerModuleReqDefaultTypeInternal _UpdateContainerModuleReq_default_instance_;
class UpdateContainerModuleRes;
class UpdateContainerModuleResDefaultTypeInternal;
extern UpdateContainerModuleResDefaultTypeInternal _UpdateContainerModuleRes_default_instance_;
class UpgradeContainerReq;
class UpgradeContainerReqDefaultTypeInternal;
extern UpgradeContainerReqDefaultTypeInternal _UpgradeContainerReq_default_instance_;
class UpgradeContainerRes;
class UpgradeContainerResDefaultTypeInternal;
extern UpgradeContainerResDefaultTypeInternal _UpgradeContainerRes_default_instance_;
}  // namespace cmongoproto

namespace cmongoproto {

namespace protobuf_cmongo_2fcmongoproto_2fcmongo_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_cmongo_2fcmongoproto_2fcmongo_2eproto

enum MongoVersion {
  MONGO_2 = 0,
  MONGO_3_MMAP = 1,
  MONGO_3_WT = 2,
  MONGO_3_ROCKS = 3,
  MongoVersion_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MongoVersion_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MongoVersion_IsValid(int value);
const MongoVersion MongoVersion_MIN = MONGO_2;
const MongoVersion MongoVersion_MAX = MONGO_3_ROCKS;
const int MongoVersion_ARRAYSIZE = MongoVersion_MAX + 1;

const ::google::protobuf::EnumDescriptor* MongoVersion_descriptor();
inline const ::std::string& MongoVersion_Name(MongoVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    MongoVersion_descriptor(), value);
}
inline bool MongoVersion_Parse(
    const ::std::string& name, MongoVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MongoVersion>(
    MongoVersion_descriptor(), name, value);
}
enum MongoType {
  MONGOD = 0,
  MONGOS = 1,
  CONFIG = 2,
  PROXY = 3,
  PROXY2 = 4,
  DYNAMOPROXY = 5,
  MongoType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MongoType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MongoType_IsValid(int value);
const MongoType MongoType_MIN = MONGOD;
const MongoType MongoType_MAX = DYNAMOPROXY;
const int MongoType_ARRAYSIZE = MongoType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MongoType_descriptor();
inline const ::std::string& MongoType_Name(MongoType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MongoType_descriptor(), value);
}
inline bool MongoType_Parse(
    const ::std::string& name, MongoType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MongoType>(
    MongoType_descriptor(), name, value);
}
enum MemberType {
  SLAVE = 0,
  ARBITER = 1,
  DELAY = 2,
  MemberType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MemberType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MemberType_IsValid(int value);
const MemberType MemberType_MIN = SLAVE;
const MemberType MemberType_MAX = DELAY;
const int MemberType_ARRAYSIZE = MemberType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MemberType_descriptor();
inline const ::std::string& MemberType_Name(MemberType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MemberType_descriptor(), value);
}
inline bool MemberType_Parse(
    const ::std::string& name, MemberType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MemberType>(
    MemberType_descriptor(), name, value);
}
// ===================================================================

class ReqHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmongoproto.ReqHeader) */ {
 public:
  ReqHeader();
  virtual ~ReqHeader();

  ReqHeader(const ReqHeader& from);

  inline ReqHeader& operator=(const ReqHeader& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqHeader& default_instance();

  static inline const ReqHeader* internal_default_instance() {
    return reinterpret_cast<const ReqHeader*>(
               &_ReqHeader_default_instance_);
  }

  void Swap(ReqHeader* other);

  // implements Message ----------------------------------------------

  inline ReqHeader* New() const PROTOBUF_FINAL { return New(NULL); }

  ReqHeader* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReqHeader& from);
  void MergeFrom(const ReqHeader& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReqHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 version = 1;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::int32 version() const;
  void set_version(::google::protobuf::int32 value);

  // int32 reqtype = 2;
  void clear_reqtype();
  static const int kReqtypeFieldNumber = 2;
  ::google::protobuf::int32 reqtype() const;
  void set_reqtype(::google::protobuf::int32 value);

  // int64 seqid = 3;
  void clear_seqid();
  static const int kSeqidFieldNumber = 3;
  ::google::protobuf::int64 seqid() const;
  void set_seqid(::google::protobuf::int64 value);

  // int64 flag = 4;
  void clear_flag();
  static const int kFlagFieldNumber = 4;
  ::google::protobuf::int64 flag() const;
  void set_flag(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:cmongoproto.ReqHeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 version_;
  ::google::protobuf::int32 reqtype_;
  ::google::protobuf::int64 seqid_;
  ::google::protobuf::int64 flag_;
  mutable int _cached_size_;
  friend struct  protobuf_cmongo_2fcmongoproto_2fcmongo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmongoproto.ResHeader) */ {
 public:
  ResHeader();
  virtual ~ResHeader();

  ResHeader(const ResHeader& from);

  inline ResHeader& operator=(const ResHeader& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResHeader& default_instance();

  static inline const ResHeader* internal_default_instance() {
    return reinterpret_cast<const ResHeader*>(
               &_ResHeader_default_instance_);
  }

  void Swap(ResHeader* other);

  // implements Message ----------------------------------------------

  inline ResHeader* New() const PROTOBUF_FINAL { return New(NULL); }

  ResHeader* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResHeader& from);
  void MergeFrom(const ResHeader& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string ret_msg = 4;
  void clear_ret_msg();
  static const int kRetMsgFieldNumber = 4;
  const ::std::string& ret_msg() const;
  void set_ret_msg(const ::std::string& value);
  #if LANG_CXX11
  void set_ret_msg(::std::string&& value);
  #endif
  void set_ret_msg(const char* value);
  void set_ret_msg(const char* value, size_t size);
  ::std::string* mutable_ret_msg();
  ::std::string* release_ret_msg();
  void set_allocated_ret_msg(::std::string* ret_msg);

  // int64 seqid = 1;
  void clear_seqid();
  static const int kSeqidFieldNumber = 1;
  ::google::protobuf::int64 seqid() const;
  void set_seqid(::google::protobuf::int64 value);

  // int32 ret_code = 2;
  void clear_ret_code();
  static const int kRetCodeFieldNumber = 2;
  ::google::protobuf::int32 ret_code() const;
  void set_ret_code(::google::protobuf::int32 value);

  // int32 cost_time = 3;
  void clear_cost_time();
  static const int kCostTimeFieldNumber = 3;
  ::google::protobuf::int32 cost_time() const;
  void set_cost_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cmongoproto.ResHeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr ret_msg_;
  ::google::protobuf::int64 seqid_;
  ::google::protobuf::int32 ret_code_;
  ::google::protobuf::int32 cost_time_;
  mutable int _cached_size_;
  friend struct  protobuf_cmongo_2fcmongoproto_2fcmongo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResourceDesc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmongoproto.ResourceDesc) */ {
 public:
  ResourceDesc();
  virtual ~ResourceDesc();

  ResourceDesc(const ResourceDesc& from);

  inline ResourceDesc& operator=(const ResourceDesc& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceDesc& default_instance();

  static inline const ResourceDesc* internal_default_instance() {
    return reinterpret_cast<const ResourceDesc*>(
               &_ResourceDesc_default_instance_);
  }

  void Swap(ResourceDesc* other);

  // implements Message ----------------------------------------------

  inline ResourceDesc* New() const PROTOBUF_FINAL { return New(NULL); }

  ResourceDesc* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResourceDesc& from);
  void MergeFrom(const ResourceDesc& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResourceDesc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 cpu = 1;
  void clear_cpu();
  static const int kCpuFieldNumber = 1;
  ::google::protobuf::int32 cpu() const;
  void set_cpu(::google::protobuf::int32 value);

  // int32 memory = 2;
  void clear_memory();
  static const int kMemoryFieldNumber = 2;
  ::google::protobuf::int32 memory() const;
  void set_memory(::google::protobuf::int32 value);

  // int32 disk = 3;
  void clear_disk();
  static const int kDiskFieldNumber = 3;
  ::google::protobuf::int32 disk() const;
  void set_disk(::google::protobuf::int32 value);

  // int32 network = 4;
  void clear_network();
  static const int kNetworkFieldNumber = 4;
  ::google::protobuf::int32 network() const;
  void set_network(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cmongoproto.ResourceDesc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 cpu_;
  ::google::protobuf::int32 memory_;
  ::google::protobuf::int32 disk_;
  ::google::protobuf::int32 network_;
  mutable int _cached_size_;
  friend struct  protobuf_cmongo_2fcmongoproto_2fcmongo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HeartBeatReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmongoproto.HeartBeatReq) */ {
 public:
  HeartBeatReq();
  virtual ~HeartBeatReq();

  HeartBeatReq(const HeartBeatReq& from);

  inline HeartBeatReq& operator=(const HeartBeatReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartBeatReq& default_instance();

  static inline const HeartBeatReq* internal_default_instance() {
    return reinterpret_cast<const HeartBeatReq*>(
               &_HeartBeatReq_default_instance_);
  }

  void Swap(HeartBeatReq* other);

  // implements Message ----------------------------------------------

  inline HeartBeatReq* New() const PROTOBUF_FINAL { return New(NULL); }

  HeartBeatReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HeartBeatReq& from);
  void MergeFrom(const HeartBeatReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HeartBeatReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .cmongoproto.ReqHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cmongoproto::ReqHeader& header() const;
  ::cmongoproto::ReqHeader* mutable_header();
  ::cmongoproto::ReqHeader* release_header();
  void set_allocated_header(::cmongoproto::ReqHeader* header);

  // int32 container_num = 2;
  void clear_container_num();
  static const int kContainerNumFieldNumber = 2;
  ::google::protobuf::int32 container_num() const;
  void set_container_num(::google::protobuf::int32 value);

  // int32 machine_version = 3;
  void clear_machine_version();
  static const int kMachineVersionFieldNumber = 3;
  ::google::protobuf::int32 machine_version() const;
  void set_machine_version(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cmongoproto.HeartBeatReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cmongoproto::ReqHeader* header_;
  ::google::protobuf::int32 container_num_;
  ::google::protobuf::int32 machine_version_;
  mutable int _cached_size_;
  friend struct  protobuf_cmongo_2fcmongoproto_2fcmongo_2eproto::TableStruct;
};
// -------------------------------------------------------------------


// -------------------------------------------------------------------


// -------------------------------------------------------------------

class HeartBeatRes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmongoproto.HeartBeatRes) */ {
 public:
  HeartBeatRes();
  virtual ~HeartBeatRes();

  HeartBeatRes(const HeartBeatRes& from);

  inline HeartBeatRes& operator=(const HeartBeatRes& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartBeatRes& default_instance();

  static inline const HeartBeatRes* internal_default_instance() {
    return reinterpret_cast<const HeartBeatRes*>(
               &_HeartBeatRes_default_instance_);
  }

  void Swap(HeartBeatRes* other);

  // implements Message ----------------------------------------------

  inline HeartBeatRes* New() const PROTOBUF_FINAL { return New(NULL); }

  HeartBeatRes* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HeartBeatRes& from);
  void MergeFrom(const HeartBeatRes& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HeartBeatRes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<int32, .cmongoproto.ResourceDesc> containers = 3;
  int containers_size() const;
  void clear_containers();
  static const int kContainersFieldNumber = 3;
  const ::google::protobuf::Map< ::google::protobuf::int32, ::cmongoproto::ResourceDesc >&
      containers() const;
  ::google::protobuf::Map< ::google::protobuf::int32, ::cmongoproto::ResourceDesc >*
      mutable_containers();

  // map<int32, int32> running = 4;
  int running_size() const;
  void clear_running();
  static const int kRunningFieldNumber = 4;
  const ::google::protobuf::Map< ::google::protobuf::int32, ::google::protobuf::int32 >&
      running() const;
  ::google::protobuf::Map< ::google::protobuf::int32, ::google::protobuf::int32 >*
      mutable_running();

  // .cmongoproto.ResHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cmongoproto::ResHeader& header() const;
  ::cmongoproto::ResHeader* mutable_header();
  ::cmongoproto::ResHeader* release_header();
  void set_allocated_header(::cmongoproto::ResHeader* header);

  // .cmongoproto.ResourceDesc machine = 2;
  bool has_machine() const;
  void clear_machine();
  static const int kMachineFieldNumber = 2;
  const ::cmongoproto::ResourceDesc& machine() const;
  ::cmongoproto::ResourceDesc* mutable_machine();
  ::cmongoproto::ResourceDesc* release_machine();
  void set_allocated_machine(::cmongoproto::ResourceDesc* machine);

  // @@protoc_insertion_point(class_scope:cmongoproto.HeartBeatRes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  typedef ::google::protobuf::internal::MapEntryLite<
      ::google::protobuf::int32, ::cmongoproto::ResourceDesc,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 >
      HeartBeatRes_ContainersEntry;
  ::google::protobuf::internal::MapField<
      ::google::protobuf::int32, ::cmongoproto::ResourceDesc,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > containers_;
  typedef ::google::protobuf::internal::MapEntryLite<
      ::google::protobuf::int32, ::google::protobuf::int32,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      0 >
      HeartBeatRes_RunningEntry;
  ::google::protobuf::internal::MapField<
      ::google::protobuf::int32, ::google::protobuf::int32,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      0 > running_;
  ::cmongoproto::ResHeader* header_;
  ::cmongoproto::ResourceDesc* machine_;
  mutable int _cached_size_;
  friend struct  protobuf_cmongo_2fcmongoproto_2fcmongo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MongoDParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmongoproto.MongoDParam) */ {
 public:
  MongoDParam();
  virtual ~MongoDParam();

  MongoDParam(const MongoDParam& from);

  inline MongoDParam& operator=(const MongoDParam& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MongoDParam& default_instance();

  static inline const MongoDParam* internal_default_instance() {
    return reinterpret_cast<const MongoDParam*>(
               &_MongoDParam_default_instance_);
  }

  void Swap(MongoDParam* other);

  // implements Message ----------------------------------------------

  inline MongoDParam* New() const PROTOBUF_FINAL { return New(NULL); }

  MongoDParam* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MongoDParam& from);
  void MergeFrom(const MongoDParam& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MongoDParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string cluster_name = 1;
  void clear_cluster_name();
  static const int kClusterNameFieldNumber = 1;
  const ::std::string& cluster_name() const;
  void set_cluster_name(const ::std::string& value);
  #if LANG_CXX11
  void set_cluster_name(::std::string&& value);
  #endif
  void set_cluster_name(const char* value);
  void set_cluster_name(const char* value, size_t size);
  ::std::string* mutable_cluster_name();
  ::std::string* release_cluster_name();
  void set_allocated_cluster_name(::std::string* cluster_name);

  // string rs_name = 2;
  void clear_rs_name();
  static const int kRsNameFieldNumber = 2;
  const ::std::string& rs_name() const;
  void set_rs_name(const ::std::string& value);
  #if LANG_CXX11
  void set_rs_name(::std::string&& value);
  #endif
  void set_rs_name(const char* value);
  void set_rs_name(const char* value, size_t size);
  ::std::string* mutable_rs_name();
  ::std::string* release_rs_name();
  void set_allocated_rs_name(::std::string* rs_name);

  // @@protoc_insertion_point(class_scope:cmongoproto.MongoDParam)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr cluster_name_;
  ::google::protobuf::internal::ArenaStringPtr rs_name_;
  mutable int _cached_size_;
  friend struct  protobuf_cmongo_2fcmongoproto_2fcmongo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ConfigParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmongoproto.ConfigParam) */ {
 public:
  ConfigParam();
  virtual ~ConfigParam();

  ConfigParam(const ConfigParam& from);

  inline ConfigParam& operator=(const ConfigParam& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConfigParam& default_instance();

  static inline const ConfigParam* internal_default_instance() {
    return reinterpret_cast<const ConfigParam*>(
               &_ConfigParam_default_instance_);
  }

  void Swap(ConfigParam* other);

  // implements Message ----------------------------------------------

  inline ConfigParam* New() const PROTOBUF_FINAL { return New(NULL); }

  ConfigParam* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ConfigParam& from);
  void MergeFrom(const ConfigParam& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ConfigParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string cluster_name = 1;
  void clear_cluster_name();
  static const int kClusterNameFieldNumber = 1;
  const ::std::string& cluster_name() const;
  void set_cluster_name(const ::std::string& value);
  #if LANG_CXX11
  void set_cluster_name(::std::string&& value);
  #endif
  void set_cluster_name(const char* value);
  void set_cluster_name(const char* value, size_t size);
  ::std::string* mutable_cluster_name();
  ::std::string* release_cluster_name();
  void set_allocated_cluster_name(::std::string* cluster_name);

  // @@protoc_insertion_point(class_scope:cmongoproto.ConfigParam)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr cluster_name_;
  mutable int _cached_size_;
  friend struct  protobuf_cmongo_2fcmongoproto_2fcmongo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MongoSParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmongoproto.MongoSParam) */ {
 public:
  MongoSParam();
  virtual ~MongoSParam();

  MongoSParam(const MongoSParam& from);

  inline MongoSParam& operator=(const MongoSParam& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MongoSParam& default_instance();

  static inline const MongoSParam* internal_default_instance() {
    return reinterpret_cast<const MongoSParam*>(
               &_MongoSParam_default_instance_);
  }

  void Swap(MongoSParam* other);

  // implements Message ----------------------------------------------

  inline MongoSParam* New() const PROTOBUF_FINAL { return New(NULL); }

  MongoSParam* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MongoSParam& from);
  void MergeFrom(const MongoSParam& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MongoSParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string cluster_name = 1;
  void clear_cluster_name();
  static const int kClusterNameFieldNumber = 1;
  const ::std::string& cluster_name() const;
  void set_cluster_name(const ::std::string& value);
  #if LANG_CXX11
  void set_cluster_name(::std::string&& value);
  #endif
  void set_cluster_name(const char* value);
  void set_cluster_name(const char* value, size_t size);
  ::std::string* mutable_cluster_name();
  ::std::string* release_cluster_name();
  void set_allocated_cluster_name(::std::string* cluster_name);

  // string config_addr = 2;
  void clear_config_addr();
  static const int kConfigAddrFieldNumber = 2;
  const ::std::string& config_addr() const;
  void set_config_addr(const ::std::string& value);
  #if LANG_CXX11
  void set_config_addr(::std::string&& value);
  #endif
  void set_config_addr(const char* value);
  void set_config_addr(const char* value, size_t size);
  ::std::string* mutable_config_addr();
  ::std::string* release_config_addr();
  void set_allocated_config_addr(::std::string* config_addr);

  // @@protoc_insertion_point(class_scope:cmongoproto.MongoSParam)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr cluster_name_;
  ::google::protobuf::internal::ArenaStringPtr config_addr_;
  mutable int _cached_size_;
  friend struct  protobuf_cmongo_2fcmongoproto_2fcmongo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProxyParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmongoproto.ProxyParam) */ {
 public:
  ProxyParam();
  virtual ~ProxyParam();

  ProxyParam(const ProxyParam& from);

  inline ProxyParam& operator=(const ProxyParam& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProxyParam& default_instance();

  static inline const ProxyParam* internal_default_instance() {
    return reinterpret_cast<const ProxyParam*>(
               &_ProxyParam_default_instance_);
  }

  void Swap(ProxyParam* other);

  // implements Message ----------------------------------------------

  inline ProxyParam* New() const PROTOBUF_FINAL { return New(NULL); }

  ProxyParam* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProxyParam& from);
  void MergeFrom(const ProxyParam& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProxyParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string seed = 2;
  int seed_size() const;
  void clear_seed();
  static const int kSeedFieldNumber = 2;
  const ::std::string& seed(int index) const;
  ::std::string* mutable_seed(int index);
  void set_seed(int index, const ::std::string& value);
  void set_seed(int index, const char* value);
  void set_seed(int index, const char* value, size_t size);
  ::std::string* add_seed();
  void add_seed(const ::std::string& value);
  void add_seed(const char* value);
  void add_seed(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& seed() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_seed();

  // repeated string endPoints = 3;
  int endpoints_size() const;
  void clear_endpoints();
  static const int kEndPointsFieldNumber = 3;
  const ::std::string& endpoints(int index) const;
  ::std::string* mutable_endpoints(int index);
  void set_endpoints(int index, const ::std::string& value);
  void set_endpoints(int index, const char* value);
  void set_endpoints(int index, const char* value, size_t size);
  ::std::string* add_endpoints();
  void add_endpoints(const ::std::string& value);
  void add_endpoints(const char* value);
  void add_endpoints(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& endpoints() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_endpoints();

  // string rs_name = 1;
  void clear_rs_name();
  static const int kRsNameFieldNumber = 1;
  const ::std::string& rs_name() const;
  void set_rs_name(const ::std::string& value);
  #if LANG_CXX11
  void set_rs_name(::std::string&& value);
  #endif
  void set_rs_name(const char* value);
  void set_rs_name(const char* value, size_t size);
  ::std::string* mutable_rs_name();
  ::std::string* release_rs_name();
  void set_allocated_rs_name(::std::string* rs_name);

  // @@protoc_insertion_point(class_scope:cmongoproto.ProxyParam)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> seed_;
  ::google::protobuf::RepeatedPtrField< ::std::string> endpoints_;
  ::google::protobuf::internal::ArenaStringPtr rs_name_;
  mutable int _cached_size_;
  friend struct  protobuf_cmongo_2fcmongoproto_2fcmongo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Proxy2Param : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmongoproto.Proxy2Param) */ {
 public:
  Proxy2Param();
  virtual ~Proxy2Param();

  Proxy2Param(const Proxy2Param& from);

  inline Proxy2Param& operator=(const Proxy2Param& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Proxy2Param& default_instance();

  static inline const Proxy2Param* internal_default_instance() {
    return reinterpret_cast<const Proxy2Param*>(
               &_Proxy2Param_default_instance_);
  }

  void Swap(Proxy2Param* other);

  // implements Message ----------------------------------------------

  inline Proxy2Param* New() const PROTOBUF_FINAL { return New(NULL); }

  Proxy2Param* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Proxy2Param& from);
  void MergeFrom(const Proxy2Param& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Proxy2Param* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string endPoints = 3;
  int endpoints_size() const;
  void clear_endpoints();
  static const int kEndPointsFieldNumber = 3;
  const ::std::string& endpoints(int index) const;
  ::std::string* mutable_endpoints(int index);
  void set_endpoints(int index, const ::std::string& value);
  void set_endpoints(int index, const char* value);
  void set_endpoints(int index, const char* value, size_t size);
  ::std::string* add_endpoints();
  void add_endpoints(const ::std::string& value);
  void add_endpoints(const char* value);
  void add_endpoints(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& endpoints() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_endpoints();

  // string cluster_name = 1;
  void clear_cluster_name();
  static const int kClusterNameFieldNumber = 1;
  const ::std::string& cluster_name() const;
  void set_cluster_name(const ::std::string& value);
  #if LANG_CXX11
  void set_cluster_name(::std::string&& value);
  #endif
  void set_cluster_name(const char* value);
  void set_cluster_name(const char* value, size_t size);
  ::std::string* mutable_cluster_name();
  ::std::string* release_cluster_name();
  void set_allocated_cluster_name(::std::string* cluster_name);

  // bool enable_shard = 2;
  void clear_enable_shard();
  static const int kEnableShardFieldNumber = 2;
  bool enable_shard() const;
  void set_enable_shard(bool value);

  // @@protoc_insertion_point(class_scope:cmongoproto.Proxy2Param)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> endpoints_;
  ::google::protobuf::internal::ArenaStringPtr cluster_name_;
  bool enable_shard_;
  mutable int _cached_size_;
  friend struct  protobuf_cmongo_2fcmongoproto_2fcmongo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DynamoProxyParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmongoproto.DynamoProxyParam) */ {
 public:
  DynamoProxyParam();
  virtual ~DynamoProxyParam();

  DynamoProxyParam(const DynamoProxyParam& from);

  inline DynamoProxyParam& operator=(const DynamoProxyParam& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DynamoProxyParam& default_instance();

  static inline const DynamoProxyParam* internal_default_instance() {
    return reinterpret_cast<const DynamoProxyParam*>(
               &_DynamoProxyParam_default_instance_);
  }

  void Swap(DynamoProxyParam* other);

  // implements Message ----------------------------------------------

  inline DynamoProxyParam* New() const PROTOBUF_FINAL { return New(NULL); }

  DynamoProxyParam* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DynamoProxyParam& from);
  void MergeFrom(const DynamoProxyParam& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DynamoProxyParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string endPoints = 2;
  int endpoints_size() const;
  void clear_endpoints();
  static const int kEndPointsFieldNumber = 2;
  const ::std::string& endpoints(int index) const;
  ::std::string* mutable_endpoints(int index);
  void set_endpoints(int index, const ::std::string& value);
  void set_endpoints(int index, const char* value);
  void set_endpoints(int index, const char* value, size_t size);
  ::std::string* add_endpoints();
  void add_endpoints(const ::std::string& value);
  void add_endpoints(const char* value);
  void add_endpoints(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& endpoints() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_endpoints();

  // string cluster_name = 1;
  void clear_cluster_name();
  static const int kClusterNameFieldNumber = 1;
  const ::std::string& cluster_name() const;
  void set_cluster_name(const ::std::string& value);
  #if LANG_CXX11
  void set_cluster_name(::std::string&& value);
  #endif
  void set_cluster_name(const char* value);
  void set_cluster_name(const char* value, size_t size);
  ::std::string* mutable_cluster_name();
  ::std::string* release_cluster_name();
  void set_allocated_cluster_name(::std::string* cluster_name);

  // @@protoc_insertion_point(class_scope:cmongoproto.DynamoProxyParam)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> endpoints_;
  ::google::protobuf::internal::ArenaStringPtr cluster_name_;
  mutable int _cached_size_;
  friend struct  protobuf_cmongo_2fcmongoproto_2fcmongo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CreateContainerReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmongoproto.CreateContainerReq) */ {
 public:
  CreateContainerReq();
  virtual ~CreateContainerReq();

  CreateContainerReq(const CreateContainerReq& from);

  inline CreateContainerReq& operator=(const CreateContainerReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateContainerReq& default_instance();

  enum ContainerParamCase {
    kMongodParams = 6,
    kMongosParams = 7,
    kConfigParams = 8,
    kProxyParams = 9,
    kProxy2Params = 10,
    kDynamoParams = 11,
    CONTAINER_PARAM_NOT_SET = 0,
  };

  static inline const CreateContainerReq* internal_default_instance() {
    return reinterpret_cast<const CreateContainerReq*>(
               &_CreateContainerReq_default_instance_);
  }

  void Swap(CreateContainerReq* other);

  // implements Message ----------------------------------------------

  inline CreateContainerReq* New() const PROTOBUF_FINAL { return New(NULL); }

  CreateContainerReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CreateContainerReq& from);
  void MergeFrom(const CreateContainerReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CreateContainerReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string proxy_version = 18;
  void clear_proxy_version();
  static const int kProxyVersionFieldNumber = 18;
  const ::std::string& proxy_version() const;
  void set_proxy_version(const ::std::string& value);
  #if LANG_CXX11
  void set_proxy_version(::std::string&& value);
  #endif
  void set_proxy_version(const char* value);
  void set_proxy_version(const char* value, size_t size);
  ::std::string* mutable_proxy_version();
  ::std::string* release_proxy_version();
  void set_allocated_proxy_version(::std::string* proxy_version);

  // string mongod_subversion = 19;
  void clear_mongod_subversion();
  static const int kMongodSubversionFieldNumber = 19;
  const ::std::string& mongod_subversion() const;
  void set_mongod_subversion(const ::std::string& value);
  #if LANG_CXX11
  void set_mongod_subversion(::std::string&& value);
  #endif
  void set_mongod_subversion(const char* value);
  void set_mongod_subversion(const char* value, size_t size);
  ::std::string* mutable_mongod_subversion();
  ::std::string* release_mongod_subversion();
  void set_allocated_mongod_subversion(::std::string* mongod_subversion);

  // string dynamo_proxy_version = 20;
  void clear_dynamo_proxy_version();
  static const int kDynamoProxyVersionFieldNumber = 20;
  const ::std::string& dynamo_proxy_version() const;
  void set_dynamo_proxy_version(const ::std::string& value);
  #if LANG_CXX11
  void set_dynamo_proxy_version(::std::string&& value);
  #endif
  void set_dynamo_proxy_version(const char* value);
  void set_dynamo_proxy_version(const char* value, size_t size);
  ::std::string* mutable_dynamo_proxy_version();
  ::std::string* release_dynamo_proxy_version();
  void set_allocated_dynamo_proxy_version(::std::string* dynamo_proxy_version);

  // string package_url = 21;
  void clear_package_url();
  static const int kPackageUrlFieldNumber = 21;
  const ::std::string& package_url() const;
  void set_package_url(const ::std::string& value);
  #if LANG_CXX11
  void set_package_url(::std::string&& value);
  #endif
  void set_package_url(const char* value);
  void set_package_url(const char* value, size_t size);
  ::std::string* mutable_package_url();
  ::std::string* release_package_url();
  void set_allocated_package_url(::std::string* package_url);

  // string user_password = 22;
  void clear_user_password();
  static const int kUserPasswordFieldNumber = 22;
  const ::std::string& user_password() const;
  void set_user_password(const ::std::string& value);
  #if LANG_CXX11
  void set_user_password(::std::string&& value);
  #endif
  void set_user_password(const char* value);
  void set_user_password(const char* value, size_t size);
  ::std::string* mutable_user_password();
  ::std::string* release_user_password();
  void set_allocated_user_password(::std::string* user_password);

  // .cmongoproto.ReqHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cmongoproto::ReqHeader& header() const;
  ::cmongoproto::ReqHeader* mutable_header();
  ::cmongoproto::ReqHeader* release_header();
  void set_allocated_header(::cmongoproto::ReqHeader* header);

  // .cmongoproto.ResourceDesc quota = 4;
  bool has_quota() const;
  void clear_quota();
  static const int kQuotaFieldNumber = 4;
  const ::cmongoproto::ResourceDesc& quota() const;
  ::cmongoproto::ResourceDesc* mutable_quota();
  ::cmongoproto::ResourceDesc* release_quota();
  void set_allocated_quota(::cmongoproto::ResourceDesc* quota);

  // int32 container_id = 2;
  void clear_container_id();
  static const int kContainerIdFieldNumber = 2;
  ::google::protobuf::int32 container_id() const;
  void set_container_id(::google::protobuf::int32 value);

  // .cmongoproto.MongoType container_type = 3;
  void clear_container_type();
  static const int kContainerTypeFieldNumber = 3;
  ::cmongoproto::MongoType container_type() const;
  void set_container_type(::cmongoproto::MongoType value);

  // .cmongoproto.MongoVersion mongo_version = 5;
  void clear_mongo_version();
  static const int kMongoVersionFieldNumber = 5;
  ::cmongoproto::MongoVersion mongo_version() const;
  void set_mongo_version(::cmongoproto::MongoVersion value);

  // .cmongoproto.MongoDParam mongod_params = 6;
  bool has_mongod_params() const;
  void clear_mongod_params();
  static const int kMongodParamsFieldNumber = 6;
  const ::cmongoproto::MongoDParam& mongod_params() const;
  ::cmongoproto::MongoDParam* mutable_mongod_params();
  ::cmongoproto::MongoDParam* release_mongod_params();
  void set_allocated_mongod_params(::cmongoproto::MongoDParam* mongod_params);

  // .cmongoproto.MongoSParam mongos_params = 7;
  bool has_mongos_params() const;
  void clear_mongos_params();
  static const int kMongosParamsFieldNumber = 7;
  const ::cmongoproto::MongoSParam& mongos_params() const;
  ::cmongoproto::MongoSParam* mutable_mongos_params();
  ::cmongoproto::MongoSParam* release_mongos_params();
  void set_allocated_mongos_params(::cmongoproto::MongoSParam* mongos_params);

  // .cmongoproto.ConfigParam config_params = 8;
  bool has_config_params() const;
  void clear_config_params();
  static const int kConfigParamsFieldNumber = 8;
  const ::cmongoproto::ConfigParam& config_params() const;
  ::cmongoproto::ConfigParam* mutable_config_params();
  ::cmongoproto::ConfigParam* release_config_params();
  void set_allocated_config_params(::cmongoproto::ConfigParam* config_params);

  // .cmongoproto.ProxyParam proxy_params = 9;
  bool has_proxy_params() const;
  void clear_proxy_params();
  static const int kProxyParamsFieldNumber = 9;
  const ::cmongoproto::ProxyParam& proxy_params() const;
  ::cmongoproto::ProxyParam* mutable_proxy_params();
  ::cmongoproto::ProxyParam* release_proxy_params();
  void set_allocated_proxy_params(::cmongoproto::ProxyParam* proxy_params);

  // .cmongoproto.Proxy2Param proxy2_params = 10;
  bool has_proxy2_params() const;
  void clear_proxy2_params();
  static const int kProxy2ParamsFieldNumber = 10;
  const ::cmongoproto::Proxy2Param& proxy2_params() const;
  ::cmongoproto::Proxy2Param* mutable_proxy2_params();
  ::cmongoproto::Proxy2Param* release_proxy2_params();
  void set_allocated_proxy2_params(::cmongoproto::Proxy2Param* proxy2_params);

  // .cmongoproto.DynamoProxyParam dynamo_params = 11;
  bool has_dynamo_params() const;
  void clear_dynamo_params();
  static const int kDynamoParamsFieldNumber = 11;
  const ::cmongoproto::DynamoProxyParam& dynamo_params() const;
  ::cmongoproto::DynamoProxyParam* mutable_dynamo_params();
  ::cmongoproto::DynamoProxyParam* release_dynamo_params();
  void set_allocated_dynamo_params(::cmongoproto::DynamoProxyParam* dynamo_params);

  ContainerParamCase container_param_case() const;
  // @@protoc_insertion_point(class_scope:cmongoproto.CreateContainerReq)
 private:
  void set_has_mongod_params();
  void set_has_mongos_params();
  void set_has_config_params();
  void set_has_proxy_params();
  void set_has_proxy2_params();
  void set_has_dynamo_params();

  inline bool has_container_param() const;
  void clear_container_param();
  inline void clear_has_container_param();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr proxy_version_;
  ::google::protobuf::internal::ArenaStringPtr mongod_subversion_;
  ::google::protobuf::internal::ArenaStringPtr dynamo_proxy_version_;
  ::google::protobuf::internal::ArenaStringPtr package_url_;
  ::google::protobuf::internal::ArenaStringPtr user_password_;
  ::cmongoproto::ReqHeader* header_;
  ::cmongoproto::ResourceDesc* quota_;
  ::google::protobuf::int32 container_id_;
  int container_type_;
  int mongo_version_;
  union ContainerParamUnion {
    ContainerParamUnion() {}
    ::cmongoproto::MongoDParam* mongod_params_;
    ::cmongoproto::MongoSParam* mongos_params_;
    ::cmongoproto::ConfigParam* config_params_;
    ::cmongoproto::ProxyParam* proxy_params_;
    ::cmongoproto::Proxy2Param* proxy2_params_;
    ::cmongoproto::DynamoProxyParam* dynamo_params_;
  } container_param_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct  protobuf_cmongo_2fcmongoproto_2fcmongo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PingReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmongoproto.PingReq) */ {
 public:
  PingReq();
  virtual ~PingReq();

  PingReq(const PingReq& from);

  inline PingReq& operator=(const PingReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PingReq& default_instance();

  static inline const PingReq* internal_default_instance() {
    return reinterpret_cast<const PingReq*>(
               &_PingReq_default_instance_);
  }

  void Swap(PingReq* other);

  // implements Message ----------------------------------------------

  inline PingReq* New() const PROTOBUF_FINAL { return New(NULL); }

  PingReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PingReq& from);
  void MergeFrom(const PingReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PingReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .cmongoproto.ReqHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cmongoproto::ReqHeader& header() const;
  ::cmongoproto::ReqHeader* mutable_header();
  ::cmongoproto::ReqHeader* release_header();
  void set_allocated_header(::cmongoproto::ReqHeader* header);

  // @@protoc_insertion_point(class_scope:cmongoproto.PingReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cmongoproto::ReqHeader* header_;
  mutable int _cached_size_;
  friend struct  protobuf_cmongo_2fcmongoproto_2fcmongo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PingRes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmongoproto.PingRes) */ {
 public:
  PingRes();
  virtual ~PingRes();

  PingRes(const PingRes& from);

  inline PingRes& operator=(const PingRes& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PingRes& default_instance();

  static inline const PingRes* internal_default_instance() {
    return reinterpret_cast<const PingRes*>(
               &_PingRes_default_instance_);
  }

  void Swap(PingRes* other);

  // implements Message ----------------------------------------------

  inline PingRes* New() const PROTOBUF_FINAL { return New(NULL); }

  PingRes* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PingRes& from);
  void MergeFrom(const PingRes& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PingRes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .cmongoproto.ResHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cmongoproto::ResHeader& header() const;
  ::cmongoproto::ResHeader* mutable_header();
  ::cmongoproto::ResHeader* release_header();
  void set_allocated_header(::cmongoproto::ResHeader* header);

  // @@protoc_insertion_point(class_scope:cmongoproto.PingRes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cmongoproto::ResHeader* header_;
  mutable int _cached_size_;
  friend struct  protobuf_cmongo_2fcmongoproto_2fcmongo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CreateContainerRes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmongoproto.CreateContainerRes) */ {
 public:
  CreateContainerRes();
  virtual ~CreateContainerRes();

  CreateContainerRes(const CreateContainerRes& from);

  inline CreateContainerRes& operator=(const CreateContainerRes& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateContainerRes& default_instance();

  static inline const CreateContainerRes* internal_default_instance() {
    return reinterpret_cast<const CreateContainerRes*>(
               &_CreateContainerRes_default_instance_);
  }

  void Swap(CreateContainerRes* other);

  // implements Message ----------------------------------------------

  inline CreateContainerRes* New() const PROTOBUF_FINAL { return New(NULL); }

  CreateContainerRes* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CreateContainerRes& from);
  void MergeFrom(const CreateContainerRes& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CreateContainerRes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .cmongoproto.ResHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cmongoproto::ResHeader& header() const;
  ::cmongoproto::ResHeader* mutable_header();
  ::cmongoproto::ResHeader* release_header();
  void set_allocated_header(::cmongoproto::ResHeader* header);

  // int32 port_used = 2;
  void clear_port_used();
  static const int kPortUsedFieldNumber = 2;
  ::google::protobuf::int32 port_used() const;
  void set_port_used(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cmongoproto.CreateContainerRes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cmongoproto::ResHeader* header_;
  ::google::protobuf::int32 port_used_;
  mutable int _cached_size_;
  friend struct  protobuf_cmongo_2fcmongoproto_2fcmongo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DestroyContainerReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmongoproto.DestroyContainerReq) */ {
 public:
  DestroyContainerReq();
  virtual ~DestroyContainerReq();

  DestroyContainerReq(const DestroyContainerReq& from);

  inline DestroyContainerReq& operator=(const DestroyContainerReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DestroyContainerReq& default_instance();

  static inline const DestroyContainerReq* internal_default_instance() {
    return reinterpret_cast<const DestroyContainerReq*>(
               &_DestroyContainerReq_default_instance_);
  }

  void Swap(DestroyContainerReq* other);

  // implements Message ----------------------------------------------

  inline DestroyContainerReq* New() const PROTOBUF_FINAL { return New(NULL); }

  DestroyContainerReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DestroyContainerReq& from);
  void MergeFrom(const DestroyContainerReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DestroyContainerReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .cmongoproto.ReqHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cmongoproto::ReqHeader& header() const;
  ::cmongoproto::ReqHeader* mutable_header();
  ::cmongoproto::ReqHeader* release_header();
  void set_allocated_header(::cmongoproto::ReqHeader* header);

  // int32 container_id = 2;
  void clear_container_id();
  static const int kContainerIdFieldNumber = 2;
  ::google::protobuf::int32 container_id() const;
  void set_container_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cmongoproto.DestroyContainerReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cmongoproto::ReqHeader* header_;
  ::google::protobuf::int32 container_id_;
  mutable int _cached_size_;
  friend struct  protobuf_cmongo_2fcmongoproto_2fcmongo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DestroyContainerRes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmongoproto.DestroyContainerRes) */ {
 public:
  DestroyContainerRes();
  virtual ~DestroyContainerRes();

  DestroyContainerRes(const DestroyContainerRes& from);

  inline DestroyContainerRes& operator=(const DestroyContainerRes& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DestroyContainerRes& default_instance();

  static inline const DestroyContainerRes* internal_default_instance() {
    return reinterpret_cast<const DestroyContainerRes*>(
               &_DestroyContainerRes_default_instance_);
  }

  void Swap(DestroyContainerRes* other);

  // implements Message ----------------------------------------------

  inline DestroyContainerRes* New() const PROTOBUF_FINAL { return New(NULL); }

  DestroyContainerRes* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DestroyContainerRes& from);
  void MergeFrom(const DestroyContainerRes& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DestroyContainerRes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .cmongoproto.ResHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cmongoproto::ResHeader& header() const;
  ::cmongoproto::ResHeader* mutable_header();
  ::cmongoproto::ResHeader* release_header();
  void set_allocated_header(::cmongoproto::ResHeader* header);

  // @@protoc_insertion_point(class_scope:cmongoproto.DestroyContainerRes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cmongoproto::ResHeader* header_;
  mutable int _cached_size_;
  friend struct  protobuf_cmongo_2fcmongoproto_2fcmongo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InfoContainerReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmongoproto.InfoContainerReq) */ {
 public:
  InfoContainerReq();
  virtual ~InfoContainerReq();

  InfoContainerReq(const InfoContainerReq& from);

  inline InfoContainerReq& operator=(const InfoContainerReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InfoContainerReq& default_instance();

  static inline const InfoContainerReq* internal_default_instance() {
    return reinterpret_cast<const InfoContainerReq*>(
               &_InfoContainerReq_default_instance_);
  }

  void Swap(InfoContainerReq* other);

  // implements Message ----------------------------------------------

  inline InfoContainerReq* New() const PROTOBUF_FINAL { return New(NULL); }

  InfoContainerReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const InfoContainerReq& from);
  void MergeFrom(const InfoContainerReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(InfoContainerReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .cmongoproto.ReqHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cmongoproto::ReqHeader& header() const;
  ::cmongoproto::ReqHeader* mutable_header();
  ::cmongoproto::ReqHeader* release_header();
  void set_allocated_header(::cmongoproto::ReqHeader* header);

  // int32 container_id = 2;
  void clear_container_id();
  static const int kContainerIdFieldNumber = 2;
  ::google::protobuf::int32 container_id() const;
  void set_container_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cmongoproto.InfoContainerReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cmongoproto::ReqHeader* header_;
  ::google::protobuf::int32 container_id_;
  mutable int _cached_size_;
  friend struct  protobuf_cmongo_2fcmongoproto_2fcmongo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InfoContainerRes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmongoproto.InfoContainerRes) */ {
 public:
  InfoContainerRes();
  virtual ~InfoContainerRes();

  InfoContainerRes(const InfoContainerRes& from);

  inline InfoContainerRes& operator=(const InfoContainerRes& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InfoContainerRes& default_instance();

  static inline const InfoContainerRes* internal_default_instance() {
    return reinterpret_cast<const InfoContainerRes*>(
               &_InfoContainerRes_default_instance_);
  }

  void Swap(InfoContainerRes* other);

  // implements Message ----------------------------------------------

  inline InfoContainerRes* New() const PROTOBUF_FINAL { return New(NULL); }

  InfoContainerRes* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const InfoContainerRes& from);
  void MergeFrom(const InfoContainerRes& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(InfoContainerRes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .cmongoproto.ResHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cmongoproto::ResHeader& header() const;
  ::cmongoproto::ResHeader* mutable_header();
  ::cmongoproto::ResHeader* release_header();
  void set_allocated_header(::cmongoproto::ResHeader* header);

  // .cmongoproto.ResourceDesc using = 2;
  bool has_using_() const;
  void clear_using_();
  static const int kUsingFieldNumber = 2;
  const ::cmongoproto::ResourceDesc& using_() const;
  ::cmongoproto::ResourceDesc* mutable_using_();
  ::cmongoproto::ResourceDesc* release_using_();
  void set_allocated_using_(::cmongoproto::ResourceDesc* using_);

  // @@protoc_insertion_point(class_scope:cmongoproto.InfoContainerRes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cmongoproto::ResHeader* header_;
  ::cmongoproto::ResourceDesc* using__;
  mutable int _cached_size_;
  friend struct  protobuf_cmongo_2fcmongoproto_2fcmongo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StartContainerReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmongoproto.StartContainerReq) */ {
 public:
  StartContainerReq();
  virtual ~StartContainerReq();

  StartContainerReq(const StartContainerReq& from);

  inline StartContainerReq& operator=(const StartContainerReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StartContainerReq& default_instance();

  static inline const StartContainerReq* internal_default_instance() {
    return reinterpret_cast<const StartContainerReq*>(
               &_StartContainerReq_default_instance_);
  }

  void Swap(StartContainerReq* other);

  // implements Message ----------------------------------------------

  inline StartContainerReq* New() const PROTOBUF_FINAL { return New(NULL); }

  StartContainerReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StartContainerReq& from);
  void MergeFrom(const StartContainerReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StartContainerReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .cmongoproto.ReqHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cmongoproto::ReqHeader& header() const;
  ::cmongoproto::ReqHeader* mutable_header();
  ::cmongoproto::ReqHeader* release_header();
  void set_allocated_header(::cmongoproto::ReqHeader* header);

  // int32 container_id = 2;
  void clear_container_id();
  static const int kContainerIdFieldNumber = 2;
  ::google::protobuf::int32 container_id() const;
  void set_container_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cmongoproto.StartContainerReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cmongoproto::ReqHeader* header_;
  ::google::protobuf::int32 container_id_;
  mutable int _cached_size_;
  friend struct  protobuf_cmongo_2fcmongoproto_2fcmongo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StartContainerRes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmongoproto.StartContainerRes) */ {
 public:
  StartContainerRes();
  virtual ~StartContainerRes();

  StartContainerRes(const StartContainerRes& from);

  inline StartContainerRes& operator=(const StartContainerRes& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StartContainerRes& default_instance();

  static inline const StartContainerRes* internal_default_instance() {
    return reinterpret_cast<const StartContainerRes*>(
               &_StartContainerRes_default_instance_);
  }

  void Swap(StartContainerRes* other);

  // implements Message ----------------------------------------------

  inline StartContainerRes* New() const PROTOBUF_FINAL { return New(NULL); }

  StartContainerRes* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StartContainerRes& from);
  void MergeFrom(const StartContainerRes& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StartContainerRes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .cmongoproto.ResHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cmongoproto::ResHeader& header() const;
  ::cmongoproto::ResHeader* mutable_header();
  ::cmongoproto::ResHeader* release_header();
  void set_allocated_header(::cmongoproto::ResHeader* header);

  // @@protoc_insertion_point(class_scope:cmongoproto.StartContainerRes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cmongoproto::ResHeader* header_;
  mutable int _cached_size_;
  friend struct  protobuf_cmongo_2fcmongoproto_2fcmongo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RSInitReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmongoproto.RSInitReq) */ {
 public:
  RSInitReq();
  virtual ~RSInitReq();

  RSInitReq(const RSInitReq& from);

  inline RSInitReq& operator=(const RSInitReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RSInitReq& default_instance();

  static inline const RSInitReq* internal_default_instance() {
    return reinterpret_cast<const RSInitReq*>(
               &_RSInitReq_default_instance_);
  }

  void Swap(RSInitReq* other);

  // implements Message ----------------------------------------------

  inline RSInitReq* New() const PROTOBUF_FINAL { return New(NULL); }

  RSInitReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RSInitReq& from);
  void MergeFrom(const RSInitReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RSInitReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string rs_ips = 4;
  int rs_ips_size() const;
  void clear_rs_ips();
  static const int kRsIpsFieldNumber = 4;
  const ::std::string& rs_ips(int index) const;
  ::std::string* mutable_rs_ips(int index);
  void set_rs_ips(int index, const ::std::string& value);
  void set_rs_ips(int index, const char* value);
  void set_rs_ips(int index, const char* value, size_t size);
  ::std::string* add_rs_ips();
  void add_rs_ips(const ::std::string& value);
  void add_rs_ips(const char* value);
  void add_rs_ips(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& rs_ips() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_rs_ips();

  // string rs_name = 3;
  void clear_rs_name();
  static const int kRsNameFieldNumber = 3;
  const ::std::string& rs_name() const;
  void set_rs_name(const ::std::string& value);
  #if LANG_CXX11
  void set_rs_name(::std::string&& value);
  #endif
  void set_rs_name(const char* value);
  void set_rs_name(const char* value, size_t size);
  ::std::string* mutable_rs_name();
  ::std::string* release_rs_name();
  void set_allocated_rs_name(::std::string* rs_name);

  // .cmongoproto.ReqHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cmongoproto::ReqHeader& header() const;
  ::cmongoproto::ReqHeader* mutable_header();
  ::cmongoproto::ReqHeader* release_header();
  void set_allocated_header(::cmongoproto::ReqHeader* header);

  // int32 container_id = 2;
  void clear_container_id();
  static const int kContainerIdFieldNumber = 2;
  ::google::protobuf::int32 container_id() const;
  void set_container_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cmongoproto.RSInitReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> rs_ips_;
  ::google::protobuf::internal::ArenaStringPtr rs_name_;
  ::cmongoproto::ReqHeader* header_;
  ::google::protobuf::int32 container_id_;
  mutable int _cached_size_;
  friend struct  protobuf_cmongo_2fcmongoproto_2fcmongo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RSInitRes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmongoproto.RSInitRes) */ {
 public:
  RSInitRes();
  virtual ~RSInitRes();

  RSInitRes(const RSInitRes& from);

  inline RSInitRes& operator=(const RSInitRes& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RSInitRes& default_instance();

  static inline const RSInitRes* internal_default_instance() {
    return reinterpret_cast<const RSInitRes*>(
               &_RSInitRes_default_instance_);
  }

  void Swap(RSInitRes* other);

  // implements Message ----------------------------------------------

  inline RSInitRes* New() const PROTOBUF_FINAL { return New(NULL); }

  RSInitRes* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RSInitRes& from);
  void MergeFrom(const RSInitRes& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RSInitRes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .cmongoproto.ResHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cmongoproto::ResHeader& header() const;
  ::cmongoproto::ResHeader* mutable_header();
  ::cmongoproto::ResHeader* release_header();
  void set_allocated_header(::cmongoproto::ResHeader* header);

  // @@protoc_insertion_point(class_scope:cmongoproto.RSInitRes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cmongoproto::ResHeader* header_;
  mutable int _cached_size_;
  friend struct  protobuf_cmongo_2fcmongoproto_2fcmongo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RSStatusReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmongoproto.RSStatusReq) */ {
 public:
  RSStatusReq();
  virtual ~RSStatusReq();

  RSStatusReq(const RSStatusReq& from);

  inline RSStatusReq& operator=(const RSStatusReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RSStatusReq& default_instance();

  static inline const RSStatusReq* internal_default_instance() {
    return reinterpret_cast<const RSStatusReq*>(
               &_RSStatusReq_default_instance_);
  }

  void Swap(RSStatusReq* other);

  // implements Message ----------------------------------------------

  inline RSStatusReq* New() const PROTOBUF_FINAL { return New(NULL); }

  RSStatusReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RSStatusReq& from);
  void MergeFrom(const RSStatusReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RSStatusReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .cmongoproto.ReqHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cmongoproto::ReqHeader& header() const;
  ::cmongoproto::ReqHeader* mutable_header();
  ::cmongoproto::ReqHeader* release_header();
  void set_allocated_header(::cmongoproto::ReqHeader* header);

  // int32 container_id = 2;
  void clear_container_id();
  static const int kContainerIdFieldNumber = 2;
  ::google::protobuf::int32 container_id() const;
  void set_container_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cmongoproto.RSStatusReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cmongoproto::ReqHeader* header_;
  ::google::protobuf::int32 container_id_;
  mutable int _cached_size_;
  friend struct  protobuf_cmongo_2fcmongoproto_2fcmongo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RSStatusRes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmongoproto.RSStatusRes) */ {
 public:
  RSStatusRes();
  virtual ~RSStatusRes();

  RSStatusRes(const RSStatusRes& from);

  inline RSStatusRes& operator=(const RSStatusRes& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RSStatusRes& default_instance();

  static inline const RSStatusRes* internal_default_instance() {
    return reinterpret_cast<const RSStatusRes*>(
               &_RSStatusRes_default_instance_);
  }

  void Swap(RSStatusRes* other);

  // implements Message ----------------------------------------------

  inline RSStatusRes* New() const PROTOBUF_FINAL { return New(NULL); }

  RSStatusRes* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RSStatusRes& from);
  void MergeFrom(const RSStatusRes& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RSStatusRes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string result = 2;
  void clear_result();
  static const int kResultFieldNumber = 2;
  const ::std::string& result() const;
  void set_result(const ::std::string& value);
  #if LANG_CXX11
  void set_result(::std::string&& value);
  #endif
  void set_result(const char* value);
  void set_result(const char* value, size_t size);
  ::std::string* mutable_result();
  ::std::string* release_result();
  void set_allocated_result(::std::string* result);

  // .cmongoproto.ResHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cmongoproto::ResHeader& header() const;
  ::cmongoproto::ResHeader* mutable_header();
  ::cmongoproto::ResHeader* release_header();
  void set_allocated_header(::cmongoproto::ResHeader* header);

  // @@protoc_insertion_point(class_scope:cmongoproto.RSStatusRes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr result_;
  ::cmongoproto::ResHeader* header_;
  mutable int _cached_size_;
  friend struct  protobuf_cmongo_2fcmongoproto_2fcmongo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RSAddReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmongoproto.RSAddReq) */ {
 public:
  RSAddReq();
  virtual ~RSAddReq();

  RSAddReq(const RSAddReq& from);

  inline RSAddReq& operator=(const RSAddReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RSAddReq& default_instance();

  static inline const RSAddReq* internal_default_instance() {
    return reinterpret_cast<const RSAddReq*>(
               &_RSAddReq_default_instance_);
  }

  void Swap(RSAddReq* other);

  // implements Message ----------------------------------------------

  inline RSAddReq* New() const PROTOBUF_FINAL { return New(NULL); }

  RSAddReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RSAddReq& from);
  void MergeFrom(const RSAddReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RSAddReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string member_ip = 4;
  void clear_member_ip();
  static const int kMemberIpFieldNumber = 4;
  const ::std::string& member_ip() const;
  void set_member_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_member_ip(::std::string&& value);
  #endif
  void set_member_ip(const char* value);
  void set_member_ip(const char* value, size_t size);
  ::std::string* mutable_member_ip();
  ::std::string* release_member_ip();
  void set_allocated_member_ip(::std::string* member_ip);

  // .cmongoproto.ReqHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cmongoproto::ReqHeader& header() const;
  ::cmongoproto::ReqHeader* mutable_header();
  ::cmongoproto::ReqHeader* release_header();
  void set_allocated_header(::cmongoproto::ReqHeader* header);

  // int32 container_id = 2;
  void clear_container_id();
  static const int kContainerIdFieldNumber = 2;
  ::google::protobuf::int32 container_id() const;
  void set_container_id(::google::protobuf::int32 value);

  // .cmongoproto.MemberType member_type = 3;
  void clear_member_type();
  static const int kMemberTypeFieldNumber = 3;
  ::cmongoproto::MemberType member_type() const;
  void set_member_type(::cmongoproto::MemberType value);

  // @@protoc_insertion_point(class_scope:cmongoproto.RSAddReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr member_ip_;
  ::cmongoproto::ReqHeader* header_;
  ::google::protobuf::int32 container_id_;
  int member_type_;
  mutable int _cached_size_;
  friend struct  protobuf_cmongo_2fcmongoproto_2fcmongo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RSAddRes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmongoproto.RSAddRes) */ {
 public:
  RSAddRes();
  virtual ~RSAddRes();

  RSAddRes(const RSAddRes& from);

  inline RSAddRes& operator=(const RSAddRes& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RSAddRes& default_instance();

  static inline const RSAddRes* internal_default_instance() {
    return reinterpret_cast<const RSAddRes*>(
               &_RSAddRes_default_instance_);
  }

  void Swap(RSAddRes* other);

  // implements Message ----------------------------------------------

  inline RSAddRes* New() const PROTOBUF_FINAL { return New(NULL); }

  RSAddRes* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RSAddRes& from);
  void MergeFrom(const RSAddRes& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RSAddRes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .cmongoproto.ResHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cmongoproto::ResHeader& header() const;
  ::cmongoproto::ResHeader* mutable_header();
  ::cmongoproto::ResHeader* release_header();
  void set_allocated_header(::cmongoproto::ResHeader* header);

  // @@protoc_insertion_point(class_scope:cmongoproto.RSAddRes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cmongoproto::ResHeader* header_;
  mutable int _cached_size_;
  friend struct  protobuf_cmongo_2fcmongoproto_2fcmongo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RSRemoveReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmongoproto.RSRemoveReq) */ {
 public:
  RSRemoveReq();
  virtual ~RSRemoveReq();

  RSRemoveReq(const RSRemoveReq& from);

  inline RSRemoveReq& operator=(const RSRemoveReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RSRemoveReq& default_instance();

  static inline const RSRemoveReq* internal_default_instance() {
    return reinterpret_cast<const RSRemoveReq*>(
               &_RSRemoveReq_default_instance_);
  }

  void Swap(RSRemoveReq* other);

  // implements Message ----------------------------------------------

  inline RSRemoveReq* New() const PROTOBUF_FINAL { return New(NULL); }

  RSRemoveReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RSRemoveReq& from);
  void MergeFrom(const RSRemoveReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RSRemoveReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string member_ip = 3;
  void clear_member_ip();
  static const int kMemberIpFieldNumber = 3;
  const ::std::string& member_ip() const;
  void set_member_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_member_ip(::std::string&& value);
  #endif
  void set_member_ip(const char* value);
  void set_member_ip(const char* value, size_t size);
  ::std::string* mutable_member_ip();
  ::std::string* release_member_ip();
  void set_allocated_member_ip(::std::string* member_ip);

  // .cmongoproto.ReqHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cmongoproto::ReqHeader& header() const;
  ::cmongoproto::ReqHeader* mutable_header();
  ::cmongoproto::ReqHeader* release_header();
  void set_allocated_header(::cmongoproto::ReqHeader* header);

  // int32 container_id = 2;
  void clear_container_id();
  static const int kContainerIdFieldNumber = 2;
  ::google::protobuf::int32 container_id() const;
  void set_container_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cmongoproto.RSRemoveReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr member_ip_;
  ::cmongoproto::ReqHeader* header_;
  ::google::protobuf::int32 container_id_;
  mutable int _cached_size_;
  friend struct  protobuf_cmongo_2fcmongoproto_2fcmongo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RSRemoveRes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmongoproto.RSRemoveRes) */ {
 public:
  RSRemoveRes();
  virtual ~RSRemoveRes();

  RSRemoveRes(const RSRemoveRes& from);

  inline RSRemoveRes& operator=(const RSRemoveRes& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RSRemoveRes& default_instance();

  static inline const RSRemoveRes* internal_default_instance() {
    return reinterpret_cast<const RSRemoveRes*>(
               &_RSRemoveRes_default_instance_);
  }

  void Swap(RSRemoveRes* other);

  // implements Message ----------------------------------------------

  inline RSRemoveRes* New() const PROTOBUF_FINAL { return New(NULL); }

  RSRemoveRes* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RSRemoveRes& from);
  void MergeFrom(const RSRemoveRes& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RSRemoveRes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .cmongoproto.ResHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cmongoproto::ResHeader& header() const;
  ::cmongoproto::ResHeader* mutable_header();
  ::cmongoproto::ResHeader* release_header();
  void set_allocated_header(::cmongoproto::ResHeader* header);

  // @@protoc_insertion_point(class_scope:cmongoproto.RSRemoveRes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cmongoproto::ResHeader* header_;
  mutable int _cached_size_;
  friend struct  protobuf_cmongo_2fcmongoproto_2fcmongo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StopContainerReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmongoproto.StopContainerReq) */ {
 public:
  StopContainerReq();
  virtual ~StopContainerReq();

  StopContainerReq(const StopContainerReq& from);

  inline StopContainerReq& operator=(const StopContainerReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StopContainerReq& default_instance();

  static inline const StopContainerReq* internal_default_instance() {
    return reinterpret_cast<const StopContainerReq*>(
               &_StopContainerReq_default_instance_);
  }

  void Swap(StopContainerReq* other);

  // implements Message ----------------------------------------------

  inline StopContainerReq* New() const PROTOBUF_FINAL { return New(NULL); }

  StopContainerReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StopContainerReq& from);
  void MergeFrom(const StopContainerReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StopContainerReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .cmongoproto.ReqHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cmongoproto::ReqHeader& header() const;
  ::cmongoproto::ReqHeader* mutable_header();
  ::cmongoproto::ReqHeader* release_header();
  void set_allocated_header(::cmongoproto::ReqHeader* header);

  // int32 container_id = 2;
  void clear_container_id();
  static const int kContainerIdFieldNumber = 2;
  ::google::protobuf::int32 container_id() const;
  void set_container_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cmongoproto.StopContainerReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cmongoproto::ReqHeader* header_;
  ::google::protobuf::int32 container_id_;
  mutable int _cached_size_;
  friend struct  protobuf_cmongo_2fcmongoproto_2fcmongo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StopContainerRes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmongoproto.StopContainerRes) */ {
 public:
  StopContainerRes();
  virtual ~StopContainerRes();

  StopContainerRes(const StopContainerRes& from);

  inline StopContainerRes& operator=(const StopContainerRes& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StopContainerRes& default_instance();

  static inline const StopContainerRes* internal_default_instance() {
    return reinterpret_cast<const StopContainerRes*>(
               &_StopContainerRes_default_instance_);
  }

  void Swap(StopContainerRes* other);

  // implements Message ----------------------------------------------

  inline StopContainerRes* New() const PROTOBUF_FINAL { return New(NULL); }

  StopContainerRes* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StopContainerRes& from);
  void MergeFrom(const StopContainerRes& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StopContainerRes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .cmongoproto.ResHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cmongoproto::ResHeader& header() const;
  ::cmongoproto::ResHeader* mutable_header();
  ::cmongoproto::ResHeader* release_header();
  void set_allocated_header(::cmongoproto::ResHeader* header);

  // @@protoc_insertion_point(class_scope:cmongoproto.StopContainerRes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cmongoproto::ResHeader* header_;
  mutable int _cached_size_;
  friend struct  protobuf_cmongo_2fcmongoproto_2fcmongo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CommandContainerReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmongoproto.CommandContainerReq) */ {
 public:
  CommandContainerReq();
  virtual ~CommandContainerReq();

  CommandContainerReq(const CommandContainerReq& from);

  inline CommandContainerReq& operator=(const CommandContainerReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandContainerReq& default_instance();

  static inline const CommandContainerReq* internal_default_instance() {
    return reinterpret_cast<const CommandContainerReq*>(
               &_CommandContainerReq_default_instance_);
  }

  void Swap(CommandContainerReq* other);

  // implements Message ----------------------------------------------

  inline CommandContainerReq* New() const PROTOBUF_FINAL { return New(NULL); }

  CommandContainerReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CommandContainerReq& from);
  void MergeFrom(const CommandContainerReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CommandContainerReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string command = 3;
  void clear_command();
  static const int kCommandFieldNumber = 3;
  const ::std::string& command() const;
  void set_command(const ::std::string& value);
  #if LANG_CXX11
  void set_command(::std::string&& value);
  #endif
  void set_command(const char* value);
  void set_command(const char* value, size_t size);
  ::std::string* mutable_command();
  ::std::string* release_command();
  void set_allocated_command(::std::string* command);

  // .cmongoproto.ReqHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cmongoproto::ReqHeader& header() const;
  ::cmongoproto::ReqHeader* mutable_header();
  ::cmongoproto::ReqHeader* release_header();
  void set_allocated_header(::cmongoproto::ReqHeader* header);

  // int32 container_id = 2;
  void clear_container_id();
  static const int kContainerIdFieldNumber = 2;
  ::google::protobuf::int32 container_id() const;
  void set_container_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cmongoproto.CommandContainerReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr command_;
  ::cmongoproto::ReqHeader* header_;
  ::google::protobuf::int32 container_id_;
  mutable int _cached_size_;
  friend struct  protobuf_cmongo_2fcmongoproto_2fcmongo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CommandContainerRes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmongoproto.CommandContainerRes) */ {
 public:
  CommandContainerRes();
  virtual ~CommandContainerRes();

  CommandContainerRes(const CommandContainerRes& from);

  inline CommandContainerRes& operator=(const CommandContainerRes& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandContainerRes& default_instance();

  static inline const CommandContainerRes* internal_default_instance() {
    return reinterpret_cast<const CommandContainerRes*>(
               &_CommandContainerRes_default_instance_);
  }

  void Swap(CommandContainerRes* other);

  // implements Message ----------------------------------------------

  inline CommandContainerRes* New() const PROTOBUF_FINAL { return New(NULL); }

  CommandContainerRes* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CommandContainerRes& from);
  void MergeFrom(const CommandContainerRes& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CommandContainerRes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .cmongoproto.ResHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cmongoproto::ResHeader& header() const;
  ::cmongoproto::ResHeader* mutable_header();
  ::cmongoproto::ResHeader* release_header();
  void set_allocated_header(::cmongoproto::ResHeader* header);

  // @@protoc_insertion_point(class_scope:cmongoproto.CommandContainerRes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cmongoproto::ResHeader* header_;
  mutable int _cached_size_;
  friend struct  protobuf_cmongo_2fcmongoproto_2fcmongo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResizeContainerReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmongoproto.ResizeContainerReq) */ {
 public:
  ResizeContainerReq();
  virtual ~ResizeContainerReq();

  ResizeContainerReq(const ResizeContainerReq& from);

  inline ResizeContainerReq& operator=(const ResizeContainerReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResizeContainerReq& default_instance();

  static inline const ResizeContainerReq* internal_default_instance() {
    return reinterpret_cast<const ResizeContainerReq*>(
               &_ResizeContainerReq_default_instance_);
  }

  void Swap(ResizeContainerReq* other);

  // implements Message ----------------------------------------------

  inline ResizeContainerReq* New() const PROTOBUF_FINAL { return New(NULL); }

  ResizeContainerReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResizeContainerReq& from);
  void MergeFrom(const ResizeContainerReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResizeContainerReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .cmongoproto.ReqHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cmongoproto::ReqHeader& header() const;
  ::cmongoproto::ReqHeader* mutable_header();
  ::cmongoproto::ReqHeader* release_header();
  void set_allocated_header(::cmongoproto::ReqHeader* header);

  // .cmongoproto.ResourceDesc quota = 3;
  bool has_quota() const;
  void clear_quota();
  static const int kQuotaFieldNumber = 3;
  const ::cmongoproto::ResourceDesc& quota() const;
  ::cmongoproto::ResourceDesc* mutable_quota();
  ::cmongoproto::ResourceDesc* release_quota();
  void set_allocated_quota(::cmongoproto::ResourceDesc* quota);

  // int32 container_id = 2;
  void clear_container_id();
  static const int kContainerIdFieldNumber = 2;
  ::google::protobuf::int32 container_id() const;
  void set_container_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cmongoproto.ResizeContainerReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cmongoproto::ReqHeader* header_;
  ::cmongoproto::ResourceDesc* quota_;
  ::google::protobuf::int32 container_id_;
  mutable int _cached_size_;
  friend struct  protobuf_cmongo_2fcmongoproto_2fcmongo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResizeContainerRes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmongoproto.ResizeContainerRes) */ {
 public:
  ResizeContainerRes();
  virtual ~ResizeContainerRes();

  ResizeContainerRes(const ResizeContainerRes& from);

  inline ResizeContainerRes& operator=(const ResizeContainerRes& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResizeContainerRes& default_instance();

  static inline const ResizeContainerRes* internal_default_instance() {
    return reinterpret_cast<const ResizeContainerRes*>(
               &_ResizeContainerRes_default_instance_);
  }

  void Swap(ResizeContainerRes* other);

  // implements Message ----------------------------------------------

  inline ResizeContainerRes* New() const PROTOBUF_FINAL { return New(NULL); }

  ResizeContainerRes* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResizeContainerRes& from);
  void MergeFrom(const ResizeContainerRes& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResizeContainerRes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .cmongoproto.ResHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cmongoproto::ResHeader& header() const;
  ::cmongoproto::ResHeader* mutable_header();
  ::cmongoproto::ResHeader* release_header();
  void set_allocated_header(::cmongoproto::ResHeader* header);

  // @@protoc_insertion_point(class_scope:cmongoproto.ResizeContainerRes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cmongoproto::ResHeader* header_;
  mutable int _cached_size_;
  friend struct  protobuf_cmongo_2fcmongoproto_2fcmongo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UpgradeContainerReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmongoproto.UpgradeContainerReq) */ {
 public:
  UpgradeContainerReq();
  virtual ~UpgradeContainerReq();

  UpgradeContainerReq(const UpgradeContainerReq& from);

  inline UpgradeContainerReq& operator=(const UpgradeContainerReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpgradeContainerReq& default_instance();

  static inline const UpgradeContainerReq* internal_default_instance() {
    return reinterpret_cast<const UpgradeContainerReq*>(
               &_UpgradeContainerReq_default_instance_);
  }

  void Swap(UpgradeContainerReq* other);

  // implements Message ----------------------------------------------

  inline UpgradeContainerReq* New() const PROTOBUF_FINAL { return New(NULL); }

  UpgradeContainerReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UpgradeContainerReq& from);
  void MergeFrom(const UpgradeContainerReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UpgradeContainerReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string conf = 3;
  void clear_conf();
  static const int kConfFieldNumber = 3;
  const ::std::string& conf() const;
  void set_conf(const ::std::string& value);
  #if LANG_CXX11
  void set_conf(::std::string&& value);
  #endif
  void set_conf(const char* value);
  void set_conf(const char* value, size_t size);
  ::std::string* mutable_conf();
  ::std::string* release_conf();
  void set_allocated_conf(::std::string* conf);

  // .cmongoproto.ReqHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cmongoproto::ReqHeader& header() const;
  ::cmongoproto::ReqHeader* mutable_header();
  ::cmongoproto::ReqHeader* release_header();
  void set_allocated_header(::cmongoproto::ReqHeader* header);

  // int32 container_id = 2;
  void clear_container_id();
  static const int kContainerIdFieldNumber = 2;
  ::google::protobuf::int32 container_id() const;
  void set_container_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cmongoproto.UpgradeContainerReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr conf_;
  ::cmongoproto::ReqHeader* header_;
  ::google::protobuf::int32 container_id_;
  mutable int _cached_size_;
  friend struct  protobuf_cmongo_2fcmongoproto_2fcmongo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UpgradeContainerRes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmongoproto.UpgradeContainerRes) */ {
 public:
  UpgradeContainerRes();
  virtual ~UpgradeContainerRes();

  UpgradeContainerRes(const UpgradeContainerRes& from);

  inline UpgradeContainerRes& operator=(const UpgradeContainerRes& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpgradeContainerRes& default_instance();

  static inline const UpgradeContainerRes* internal_default_instance() {
    return reinterpret_cast<const UpgradeContainerRes*>(
               &_UpgradeContainerRes_default_instance_);
  }

  void Swap(UpgradeContainerRes* other);

  // implements Message ----------------------------------------------

  inline UpgradeContainerRes* New() const PROTOBUF_FINAL { return New(NULL); }

  UpgradeContainerRes* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UpgradeContainerRes& from);
  void MergeFrom(const UpgradeContainerRes& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UpgradeContainerRes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .cmongoproto.ResHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cmongoproto::ResHeader& header() const;
  ::cmongoproto::ResHeader* mutable_header();
  ::cmongoproto::ResHeader* release_header();
  void set_allocated_header(::cmongoproto::ResHeader* header);

  // @@protoc_insertion_point(class_scope:cmongoproto.UpgradeContainerRes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cmongoproto::ResHeader* header_;
  mutable int _cached_size_;
  friend struct  protobuf_cmongo_2fcmongoproto_2fcmongo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UpdateContainerModuleReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmongoproto.UpdateContainerModuleReq) */ {
 public:
  UpdateContainerModuleReq();
  virtual ~UpdateContainerModuleReq();

  UpdateContainerModuleReq(const UpdateContainerModuleReq& from);

  inline UpdateContainerModuleReq& operator=(const UpdateContainerModuleReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateContainerModuleReq& default_instance();

  static inline const UpdateContainerModuleReq* internal_default_instance() {
    return reinterpret_cast<const UpdateContainerModuleReq*>(
               &_UpdateContainerModuleReq_default_instance_);
  }

  void Swap(UpdateContainerModuleReq* other);

  // implements Message ----------------------------------------------

  inline UpdateContainerModuleReq* New() const PROTOBUF_FINAL { return New(NULL); }

  UpdateContainerModuleReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UpdateContainerModuleReq& from);
  void MergeFrom(const UpdateContainerModuleReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UpdateContainerModuleReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string module_version = 4;
  void clear_module_version();
  static const int kModuleVersionFieldNumber = 4;
  const ::std::string& module_version() const;
  void set_module_version(const ::std::string& value);
  #if LANG_CXX11
  void set_module_version(::std::string&& value);
  #endif
  void set_module_version(const char* value);
  void set_module_version(const char* value, size_t size);
  ::std::string* mutable_module_version();
  ::std::string* release_module_version();
  void set_allocated_module_version(::std::string* module_version);

  // string package_url = 6;
  void clear_package_url();
  static const int kPackageUrlFieldNumber = 6;
  const ::std::string& package_url() const;
  void set_package_url(const ::std::string& value);
  #if LANG_CXX11
  void set_package_url(::std::string&& value);
  #endif
  void set_package_url(const char* value);
  void set_package_url(const char* value, size_t size);
  ::std::string* mutable_package_url();
  ::std::string* release_package_url();
  void set_allocated_package_url(::std::string* package_url);

  // string user_password = 7;
  void clear_user_password();
  static const int kUserPasswordFieldNumber = 7;
  const ::std::string& user_password() const;
  void set_user_password(const ::std::string& value);
  #if LANG_CXX11
  void set_user_password(::std::string&& value);
  #endif
  void set_user_password(const char* value);
  void set_user_password(const char* value, size_t size);
  ::std::string* mutable_user_password();
  ::std::string* release_user_password();
  void set_allocated_user_password(::std::string* user_password);

  // .cmongoproto.ReqHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cmongoproto::ReqHeader& header() const;
  ::cmongoproto::ReqHeader* mutable_header();
  ::cmongoproto::ReqHeader* release_header();
  void set_allocated_header(::cmongoproto::ReqHeader* header);

  // int32 container_id = 2;
  void clear_container_id();
  static const int kContainerIdFieldNumber = 2;
  ::google::protobuf::int32 container_id() const;
  void set_container_id(::google::protobuf::int32 value);

  // .cmongoproto.MongoType ctype = 3;
  void clear_ctype();
  static const int kCtypeFieldNumber = 3;
  ::cmongoproto::MongoType ctype() const;
  void set_ctype(::cmongoproto::MongoType value);

  // int32 restart = 5;
  void clear_restart();
  static const int kRestartFieldNumber = 5;
  ::google::protobuf::int32 restart() const;
  void set_restart(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cmongoproto.UpdateContainerModuleReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr module_version_;
  ::google::protobuf::internal::ArenaStringPtr package_url_;
  ::google::protobuf::internal::ArenaStringPtr user_password_;
  ::cmongoproto::ReqHeader* header_;
  ::google::protobuf::int32 container_id_;
  int ctype_;
  ::google::protobuf::int32 restart_;
  mutable int _cached_size_;
  friend struct  protobuf_cmongo_2fcmongoproto_2fcmongo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UpdateContainerModuleRes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmongoproto.UpdateContainerModuleRes) */ {
 public:
  UpdateContainerModuleRes();
  virtual ~UpdateContainerModuleRes();

  UpdateContainerModuleRes(const UpdateContainerModuleRes& from);

  inline UpdateContainerModuleRes& operator=(const UpdateContainerModuleRes& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateContainerModuleRes& default_instance();

  static inline const UpdateContainerModuleRes* internal_default_instance() {
    return reinterpret_cast<const UpdateContainerModuleRes*>(
               &_UpdateContainerModuleRes_default_instance_);
  }

  void Swap(UpdateContainerModuleRes* other);

  // implements Message ----------------------------------------------

  inline UpdateContainerModuleRes* New() const PROTOBUF_FINAL { return New(NULL); }

  UpdateContainerModuleRes* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UpdateContainerModuleRes& from);
  void MergeFrom(const UpdateContainerModuleRes& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UpdateContainerModuleRes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .cmongoproto.ResHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cmongoproto::ResHeader& header() const;
  ::cmongoproto::ResHeader* mutable_header();
  ::cmongoproto::ResHeader* release_header();
  void set_allocated_header(::cmongoproto::ResHeader* header);

  // @@protoc_insertion_point(class_scope:cmongoproto.UpdateContainerModuleRes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cmongoproto::ResHeader* header_;
  mutable int _cached_size_;
  friend struct  protobuf_cmongo_2fcmongoproto_2fcmongo_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ReqHeader

// int32 version = 1;
inline void ReqHeader::clear_version() {
  version_ = 0;
}
inline ::google::protobuf::int32 ReqHeader::version() const {
  // @@protoc_insertion_point(field_get:cmongoproto.ReqHeader.version)
  return version_;
}
inline void ReqHeader::set_version(::google::protobuf::int32 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:cmongoproto.ReqHeader.version)
}

// int32 reqtype = 2;
inline void ReqHeader::clear_reqtype() {
  reqtype_ = 0;
}
inline ::google::protobuf::int32 ReqHeader::reqtype() const {
  // @@protoc_insertion_point(field_get:cmongoproto.ReqHeader.reqtype)
  return reqtype_;
}
inline void ReqHeader::set_reqtype(::google::protobuf::int32 value) {
  
  reqtype_ = value;
  // @@protoc_insertion_point(field_set:cmongoproto.ReqHeader.reqtype)
}

// int64 seqid = 3;
inline void ReqHeader::clear_seqid() {
  seqid_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ReqHeader::seqid() const {
  // @@protoc_insertion_point(field_get:cmongoproto.ReqHeader.seqid)
  return seqid_;
}
inline void ReqHeader::set_seqid(::google::protobuf::int64 value) {
  
  seqid_ = value;
  // @@protoc_insertion_point(field_set:cmongoproto.ReqHeader.seqid)
}

// int64 flag = 4;
inline void ReqHeader::clear_flag() {
  flag_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ReqHeader::flag() const {
  // @@protoc_insertion_point(field_get:cmongoproto.ReqHeader.flag)
  return flag_;
}
inline void ReqHeader::set_flag(::google::protobuf::int64 value) {
  
  flag_ = value;
  // @@protoc_insertion_point(field_set:cmongoproto.ReqHeader.flag)
}

// -------------------------------------------------------------------

// ResHeader

// int64 seqid = 1;
inline void ResHeader::clear_seqid() {
  seqid_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ResHeader::seqid() const {
  // @@protoc_insertion_point(field_get:cmongoproto.ResHeader.seqid)
  return seqid_;
}
inline void ResHeader::set_seqid(::google::protobuf::int64 value) {
  
  seqid_ = value;
  // @@protoc_insertion_point(field_set:cmongoproto.ResHeader.seqid)
}

// int32 ret_code = 2;
inline void ResHeader::clear_ret_code() {
  ret_code_ = 0;
}
inline ::google::protobuf::int32 ResHeader::ret_code() const {
  // @@protoc_insertion_point(field_get:cmongoproto.ResHeader.ret_code)
  return ret_code_;
}
inline void ResHeader::set_ret_code(::google::protobuf::int32 value) {
  
  ret_code_ = value;
  // @@protoc_insertion_point(field_set:cmongoproto.ResHeader.ret_code)
}

// int32 cost_time = 3;
inline void ResHeader::clear_cost_time() {
  cost_time_ = 0;
}
inline ::google::protobuf::int32 ResHeader::cost_time() const {
  // @@protoc_insertion_point(field_get:cmongoproto.ResHeader.cost_time)
  return cost_time_;
}
inline void ResHeader::set_cost_time(::google::protobuf::int32 value) {
  
  cost_time_ = value;
  // @@protoc_insertion_point(field_set:cmongoproto.ResHeader.cost_time)
}

// string ret_msg = 4;
inline void ResHeader::clear_ret_msg() {
  ret_msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResHeader::ret_msg() const {
  // @@protoc_insertion_point(field_get:cmongoproto.ResHeader.ret_msg)
  return ret_msg_.GetNoArena();
}
inline void ResHeader::set_ret_msg(const ::std::string& value) {
  
  ret_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmongoproto.ResHeader.ret_msg)
}
#if LANG_CXX11
inline void ResHeader::set_ret_msg(::std::string&& value) {
  
  ret_msg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmongoproto.ResHeader.ret_msg)
}
#endif
inline void ResHeader::set_ret_msg(const char* value) {
  
  ret_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmongoproto.ResHeader.ret_msg)
}
inline void ResHeader::set_ret_msg(const char* value, size_t size) {
  
  ret_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmongoproto.ResHeader.ret_msg)
}
inline ::std::string* ResHeader::mutable_ret_msg() {
  
  // @@protoc_insertion_point(field_mutable:cmongoproto.ResHeader.ret_msg)
  return ret_msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResHeader::release_ret_msg() {
  // @@protoc_insertion_point(field_release:cmongoproto.ResHeader.ret_msg)
  
  return ret_msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResHeader::set_allocated_ret_msg(::std::string* ret_msg) {
  if (ret_msg != NULL) {
    
  } else {
    
  }
  ret_msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ret_msg);
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.ResHeader.ret_msg)
}

// -------------------------------------------------------------------

// ResourceDesc

// int32 cpu = 1;
inline void ResourceDesc::clear_cpu() {
  cpu_ = 0;
}
inline ::google::protobuf::int32 ResourceDesc::cpu() const {
  // @@protoc_insertion_point(field_get:cmongoproto.ResourceDesc.cpu)
  return cpu_;
}
inline void ResourceDesc::set_cpu(::google::protobuf::int32 value) {
  
  cpu_ = value;
  // @@protoc_insertion_point(field_set:cmongoproto.ResourceDesc.cpu)
}

// int32 memory = 2;
inline void ResourceDesc::clear_memory() {
  memory_ = 0;
}
inline ::google::protobuf::int32 ResourceDesc::memory() const {
  // @@protoc_insertion_point(field_get:cmongoproto.ResourceDesc.memory)
  return memory_;
}
inline void ResourceDesc::set_memory(::google::protobuf::int32 value) {
  
  memory_ = value;
  // @@protoc_insertion_point(field_set:cmongoproto.ResourceDesc.memory)
}

// int32 disk = 3;
inline void ResourceDesc::clear_disk() {
  disk_ = 0;
}
inline ::google::protobuf::int32 ResourceDesc::disk() const {
  // @@protoc_insertion_point(field_get:cmongoproto.ResourceDesc.disk)
  return disk_;
}
inline void ResourceDesc::set_disk(::google::protobuf::int32 value) {
  
  disk_ = value;
  // @@protoc_insertion_point(field_set:cmongoproto.ResourceDesc.disk)
}

// int32 network = 4;
inline void ResourceDesc::clear_network() {
  network_ = 0;
}
inline ::google::protobuf::int32 ResourceDesc::network() const {
  // @@protoc_insertion_point(field_get:cmongoproto.ResourceDesc.network)
  return network_;
}
inline void ResourceDesc::set_network(::google::protobuf::int32 value) {
  
  network_ = value;
  // @@protoc_insertion_point(field_set:cmongoproto.ResourceDesc.network)
}

// -------------------------------------------------------------------

// HeartBeatReq

// .cmongoproto.ReqHeader header = 1;
inline bool HeartBeatReq::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void HeartBeatReq::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::cmongoproto::ReqHeader& HeartBeatReq::header() const {
  // @@protoc_insertion_point(field_get:cmongoproto.HeartBeatReq.header)
  return header_ != NULL ? *header_
                         : *::cmongoproto::ReqHeader::internal_default_instance();
}
inline ::cmongoproto::ReqHeader* HeartBeatReq::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::cmongoproto::ReqHeader;
  }
  // @@protoc_insertion_point(field_mutable:cmongoproto.HeartBeatReq.header)
  return header_;
}
inline ::cmongoproto::ReqHeader* HeartBeatReq::release_header() {
  // @@protoc_insertion_point(field_release:cmongoproto.HeartBeatReq.header)
  
  ::cmongoproto::ReqHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void HeartBeatReq::set_allocated_header(::cmongoproto::ReqHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.HeartBeatReq.header)
}

// int32 container_num = 2;
inline void HeartBeatReq::clear_container_num() {
  container_num_ = 0;
}
inline ::google::protobuf::int32 HeartBeatReq::container_num() const {
  // @@protoc_insertion_point(field_get:cmongoproto.HeartBeatReq.container_num)
  return container_num_;
}
inline void HeartBeatReq::set_container_num(::google::protobuf::int32 value) {
  
  container_num_ = value;
  // @@protoc_insertion_point(field_set:cmongoproto.HeartBeatReq.container_num)
}

// int32 machine_version = 3;
inline void HeartBeatReq::clear_machine_version() {
  machine_version_ = 0;
}
inline ::google::protobuf::int32 HeartBeatReq::machine_version() const {
  // @@protoc_insertion_point(field_get:cmongoproto.HeartBeatReq.machine_version)
  return machine_version_;
}
inline void HeartBeatReq::set_machine_version(::google::protobuf::int32 value) {
  
  machine_version_ = value;
  // @@protoc_insertion_point(field_set:cmongoproto.HeartBeatReq.machine_version)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// HeartBeatRes

// .cmongoproto.ResHeader header = 1;
inline bool HeartBeatRes::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void HeartBeatRes::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::cmongoproto::ResHeader& HeartBeatRes::header() const {
  // @@protoc_insertion_point(field_get:cmongoproto.HeartBeatRes.header)
  return header_ != NULL ? *header_
                         : *::cmongoproto::ResHeader::internal_default_instance();
}
inline ::cmongoproto::ResHeader* HeartBeatRes::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::cmongoproto::ResHeader;
  }
  // @@protoc_insertion_point(field_mutable:cmongoproto.HeartBeatRes.header)
  return header_;
}
inline ::cmongoproto::ResHeader* HeartBeatRes::release_header() {
  // @@protoc_insertion_point(field_release:cmongoproto.HeartBeatRes.header)
  
  ::cmongoproto::ResHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void HeartBeatRes::set_allocated_header(::cmongoproto::ResHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.HeartBeatRes.header)
}

// .cmongoproto.ResourceDesc machine = 2;
inline bool HeartBeatRes::has_machine() const {
  return this != internal_default_instance() && machine_ != NULL;
}
inline void HeartBeatRes::clear_machine() {
  if (GetArenaNoVirtual() == NULL && machine_ != NULL) delete machine_;
  machine_ = NULL;
}
inline const ::cmongoproto::ResourceDesc& HeartBeatRes::machine() const {
  // @@protoc_insertion_point(field_get:cmongoproto.HeartBeatRes.machine)
  return machine_ != NULL ? *machine_
                         : *::cmongoproto::ResourceDesc::internal_default_instance();
}
inline ::cmongoproto::ResourceDesc* HeartBeatRes::mutable_machine() {
  
  if (machine_ == NULL) {
    machine_ = new ::cmongoproto::ResourceDesc;
  }
  // @@protoc_insertion_point(field_mutable:cmongoproto.HeartBeatRes.machine)
  return machine_;
}
inline ::cmongoproto::ResourceDesc* HeartBeatRes::release_machine() {
  // @@protoc_insertion_point(field_release:cmongoproto.HeartBeatRes.machine)
  
  ::cmongoproto::ResourceDesc* temp = machine_;
  machine_ = NULL;
  return temp;
}
inline void HeartBeatRes::set_allocated_machine(::cmongoproto::ResourceDesc* machine) {
  delete machine_;
  machine_ = machine;
  if (machine) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.HeartBeatRes.machine)
}

// map<int32, .cmongoproto.ResourceDesc> containers = 3;
inline int HeartBeatRes::containers_size() const {
  return containers_.size();
}
inline void HeartBeatRes::clear_containers() {
  containers_.Clear();
}
inline const ::google::protobuf::Map< ::google::protobuf::int32, ::cmongoproto::ResourceDesc >&
HeartBeatRes::containers() const {
  // @@protoc_insertion_point(field_map:cmongoproto.HeartBeatRes.containers)
  return containers_.GetMap();
}
inline ::google::protobuf::Map< ::google::protobuf::int32, ::cmongoproto::ResourceDesc >*
HeartBeatRes::mutable_containers() {
  // @@protoc_insertion_point(field_mutable_map:cmongoproto.HeartBeatRes.containers)
  return containers_.MutableMap();
}

// map<int32, int32> running = 4;
inline int HeartBeatRes::running_size() const {
  return running_.size();
}
inline void HeartBeatRes::clear_running() {
  running_.Clear();
}
inline const ::google::protobuf::Map< ::google::protobuf::int32, ::google::protobuf::int32 >&
HeartBeatRes::running() const {
  // @@protoc_insertion_point(field_map:cmongoproto.HeartBeatRes.running)
  return running_.GetMap();
}
inline ::google::protobuf::Map< ::google::protobuf::int32, ::google::protobuf::int32 >*
HeartBeatRes::mutable_running() {
  // @@protoc_insertion_point(field_mutable_map:cmongoproto.HeartBeatRes.running)
  return running_.MutableMap();
}

// -------------------------------------------------------------------

// MongoDParam

// string cluster_name = 1;
inline void MongoDParam::clear_cluster_name() {
  cluster_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MongoDParam::cluster_name() const {
  // @@protoc_insertion_point(field_get:cmongoproto.MongoDParam.cluster_name)
  return cluster_name_.GetNoArena();
}
inline void MongoDParam::set_cluster_name(const ::std::string& value) {
  
  cluster_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmongoproto.MongoDParam.cluster_name)
}
#if LANG_CXX11
inline void MongoDParam::set_cluster_name(::std::string&& value) {
  
  cluster_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmongoproto.MongoDParam.cluster_name)
}
#endif
inline void MongoDParam::set_cluster_name(const char* value) {
  
  cluster_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmongoproto.MongoDParam.cluster_name)
}
inline void MongoDParam::set_cluster_name(const char* value, size_t size) {
  
  cluster_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmongoproto.MongoDParam.cluster_name)
}
inline ::std::string* MongoDParam::mutable_cluster_name() {
  
  // @@protoc_insertion_point(field_mutable:cmongoproto.MongoDParam.cluster_name)
  return cluster_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MongoDParam::release_cluster_name() {
  // @@protoc_insertion_point(field_release:cmongoproto.MongoDParam.cluster_name)
  
  return cluster_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MongoDParam::set_allocated_cluster_name(::std::string* cluster_name) {
  if (cluster_name != NULL) {
    
  } else {
    
  }
  cluster_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cluster_name);
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.MongoDParam.cluster_name)
}

// string rs_name = 2;
inline void MongoDParam::clear_rs_name() {
  rs_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MongoDParam::rs_name() const {
  // @@protoc_insertion_point(field_get:cmongoproto.MongoDParam.rs_name)
  return rs_name_.GetNoArena();
}
inline void MongoDParam::set_rs_name(const ::std::string& value) {
  
  rs_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmongoproto.MongoDParam.rs_name)
}
#if LANG_CXX11
inline void MongoDParam::set_rs_name(::std::string&& value) {
  
  rs_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmongoproto.MongoDParam.rs_name)
}
#endif
inline void MongoDParam::set_rs_name(const char* value) {
  
  rs_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmongoproto.MongoDParam.rs_name)
}
inline void MongoDParam::set_rs_name(const char* value, size_t size) {
  
  rs_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmongoproto.MongoDParam.rs_name)
}
inline ::std::string* MongoDParam::mutable_rs_name() {
  
  // @@protoc_insertion_point(field_mutable:cmongoproto.MongoDParam.rs_name)
  return rs_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MongoDParam::release_rs_name() {
  // @@protoc_insertion_point(field_release:cmongoproto.MongoDParam.rs_name)
  
  return rs_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MongoDParam::set_allocated_rs_name(::std::string* rs_name) {
  if (rs_name != NULL) {
    
  } else {
    
  }
  rs_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rs_name);
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.MongoDParam.rs_name)
}

// -------------------------------------------------------------------

// ConfigParam

// string cluster_name = 1;
inline void ConfigParam::clear_cluster_name() {
  cluster_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ConfigParam::cluster_name() const {
  // @@protoc_insertion_point(field_get:cmongoproto.ConfigParam.cluster_name)
  return cluster_name_.GetNoArena();
}
inline void ConfigParam::set_cluster_name(const ::std::string& value) {
  
  cluster_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmongoproto.ConfigParam.cluster_name)
}
#if LANG_CXX11
inline void ConfigParam::set_cluster_name(::std::string&& value) {
  
  cluster_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmongoproto.ConfigParam.cluster_name)
}
#endif
inline void ConfigParam::set_cluster_name(const char* value) {
  
  cluster_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmongoproto.ConfigParam.cluster_name)
}
inline void ConfigParam::set_cluster_name(const char* value, size_t size) {
  
  cluster_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmongoproto.ConfigParam.cluster_name)
}
inline ::std::string* ConfigParam::mutable_cluster_name() {
  
  // @@protoc_insertion_point(field_mutable:cmongoproto.ConfigParam.cluster_name)
  return cluster_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConfigParam::release_cluster_name() {
  // @@protoc_insertion_point(field_release:cmongoproto.ConfigParam.cluster_name)
  
  return cluster_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConfigParam::set_allocated_cluster_name(::std::string* cluster_name) {
  if (cluster_name != NULL) {
    
  } else {
    
  }
  cluster_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cluster_name);
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.ConfigParam.cluster_name)
}

// -------------------------------------------------------------------

// MongoSParam

// string cluster_name = 1;
inline void MongoSParam::clear_cluster_name() {
  cluster_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MongoSParam::cluster_name() const {
  // @@protoc_insertion_point(field_get:cmongoproto.MongoSParam.cluster_name)
  return cluster_name_.GetNoArena();
}
inline void MongoSParam::set_cluster_name(const ::std::string& value) {
  
  cluster_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmongoproto.MongoSParam.cluster_name)
}
#if LANG_CXX11
inline void MongoSParam::set_cluster_name(::std::string&& value) {
  
  cluster_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmongoproto.MongoSParam.cluster_name)
}
#endif
inline void MongoSParam::set_cluster_name(const char* value) {
  
  cluster_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmongoproto.MongoSParam.cluster_name)
}
inline void MongoSParam::set_cluster_name(const char* value, size_t size) {
  
  cluster_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmongoproto.MongoSParam.cluster_name)
}
inline ::std::string* MongoSParam::mutable_cluster_name() {
  
  // @@protoc_insertion_point(field_mutable:cmongoproto.MongoSParam.cluster_name)
  return cluster_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MongoSParam::release_cluster_name() {
  // @@protoc_insertion_point(field_release:cmongoproto.MongoSParam.cluster_name)
  
  return cluster_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MongoSParam::set_allocated_cluster_name(::std::string* cluster_name) {
  if (cluster_name != NULL) {
    
  } else {
    
  }
  cluster_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cluster_name);
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.MongoSParam.cluster_name)
}

// string config_addr = 2;
inline void MongoSParam::clear_config_addr() {
  config_addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MongoSParam::config_addr() const {
  // @@protoc_insertion_point(field_get:cmongoproto.MongoSParam.config_addr)
  return config_addr_.GetNoArena();
}
inline void MongoSParam::set_config_addr(const ::std::string& value) {
  
  config_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmongoproto.MongoSParam.config_addr)
}
#if LANG_CXX11
inline void MongoSParam::set_config_addr(::std::string&& value) {
  
  config_addr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmongoproto.MongoSParam.config_addr)
}
#endif
inline void MongoSParam::set_config_addr(const char* value) {
  
  config_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmongoproto.MongoSParam.config_addr)
}
inline void MongoSParam::set_config_addr(const char* value, size_t size) {
  
  config_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmongoproto.MongoSParam.config_addr)
}
inline ::std::string* MongoSParam::mutable_config_addr() {
  
  // @@protoc_insertion_point(field_mutable:cmongoproto.MongoSParam.config_addr)
  return config_addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MongoSParam::release_config_addr() {
  // @@protoc_insertion_point(field_release:cmongoproto.MongoSParam.config_addr)
  
  return config_addr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MongoSParam::set_allocated_config_addr(::std::string* config_addr) {
  if (config_addr != NULL) {
    
  } else {
    
  }
  config_addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), config_addr);
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.MongoSParam.config_addr)
}

// -------------------------------------------------------------------

// ProxyParam

// string rs_name = 1;
inline void ProxyParam::clear_rs_name() {
  rs_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProxyParam::rs_name() const {
  // @@protoc_insertion_point(field_get:cmongoproto.ProxyParam.rs_name)
  return rs_name_.GetNoArena();
}
inline void ProxyParam::set_rs_name(const ::std::string& value) {
  
  rs_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmongoproto.ProxyParam.rs_name)
}
#if LANG_CXX11
inline void ProxyParam::set_rs_name(::std::string&& value) {
  
  rs_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmongoproto.ProxyParam.rs_name)
}
#endif
inline void ProxyParam::set_rs_name(const char* value) {
  
  rs_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmongoproto.ProxyParam.rs_name)
}
inline void ProxyParam::set_rs_name(const char* value, size_t size) {
  
  rs_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmongoproto.ProxyParam.rs_name)
}
inline ::std::string* ProxyParam::mutable_rs_name() {
  
  // @@protoc_insertion_point(field_mutable:cmongoproto.ProxyParam.rs_name)
  return rs_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProxyParam::release_rs_name() {
  // @@protoc_insertion_point(field_release:cmongoproto.ProxyParam.rs_name)
  
  return rs_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProxyParam::set_allocated_rs_name(::std::string* rs_name) {
  if (rs_name != NULL) {
    
  } else {
    
  }
  rs_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rs_name);
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.ProxyParam.rs_name)
}

// repeated string seed = 2;
inline int ProxyParam::seed_size() const {
  return seed_.size();
}
inline void ProxyParam::clear_seed() {
  seed_.Clear();
}
inline const ::std::string& ProxyParam::seed(int index) const {
  // @@protoc_insertion_point(field_get:cmongoproto.ProxyParam.seed)
  return seed_.Get(index);
}
inline ::std::string* ProxyParam::mutable_seed(int index) {
  // @@protoc_insertion_point(field_mutable:cmongoproto.ProxyParam.seed)
  return seed_.Mutable(index);
}
inline void ProxyParam::set_seed(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:cmongoproto.ProxyParam.seed)
  seed_.Mutable(index)->assign(value);
}
inline void ProxyParam::set_seed(int index, const char* value) {
  seed_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:cmongoproto.ProxyParam.seed)
}
inline void ProxyParam::set_seed(int index, const char* value, size_t size) {
  seed_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cmongoproto.ProxyParam.seed)
}
inline ::std::string* ProxyParam::add_seed() {
  // @@protoc_insertion_point(field_add_mutable:cmongoproto.ProxyParam.seed)
  return seed_.Add();
}
inline void ProxyParam::add_seed(const ::std::string& value) {
  seed_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:cmongoproto.ProxyParam.seed)
}
inline void ProxyParam::add_seed(const char* value) {
  seed_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:cmongoproto.ProxyParam.seed)
}
inline void ProxyParam::add_seed(const char* value, size_t size) {
  seed_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:cmongoproto.ProxyParam.seed)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ProxyParam::seed() const {
  // @@protoc_insertion_point(field_list:cmongoproto.ProxyParam.seed)
  return seed_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ProxyParam::mutable_seed() {
  // @@protoc_insertion_point(field_mutable_list:cmongoproto.ProxyParam.seed)
  return &seed_;
}

// repeated string endPoints = 3;
inline int ProxyParam::endpoints_size() const {
  return endpoints_.size();
}
inline void ProxyParam::clear_endpoints() {
  endpoints_.Clear();
}
inline const ::std::string& ProxyParam::endpoints(int index) const {
  // @@protoc_insertion_point(field_get:cmongoproto.ProxyParam.endPoints)
  return endpoints_.Get(index);
}
inline ::std::string* ProxyParam::mutable_endpoints(int index) {
  // @@protoc_insertion_point(field_mutable:cmongoproto.ProxyParam.endPoints)
  return endpoints_.Mutable(index);
}
inline void ProxyParam::set_endpoints(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:cmongoproto.ProxyParam.endPoints)
  endpoints_.Mutable(index)->assign(value);
}
inline void ProxyParam::set_endpoints(int index, const char* value) {
  endpoints_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:cmongoproto.ProxyParam.endPoints)
}
inline void ProxyParam::set_endpoints(int index, const char* value, size_t size) {
  endpoints_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cmongoproto.ProxyParam.endPoints)
}
inline ::std::string* ProxyParam::add_endpoints() {
  // @@protoc_insertion_point(field_add_mutable:cmongoproto.ProxyParam.endPoints)
  return endpoints_.Add();
}
inline void ProxyParam::add_endpoints(const ::std::string& value) {
  endpoints_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:cmongoproto.ProxyParam.endPoints)
}
inline void ProxyParam::add_endpoints(const char* value) {
  endpoints_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:cmongoproto.ProxyParam.endPoints)
}
inline void ProxyParam::add_endpoints(const char* value, size_t size) {
  endpoints_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:cmongoproto.ProxyParam.endPoints)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ProxyParam::endpoints() const {
  // @@protoc_insertion_point(field_list:cmongoproto.ProxyParam.endPoints)
  return endpoints_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ProxyParam::mutable_endpoints() {
  // @@protoc_insertion_point(field_mutable_list:cmongoproto.ProxyParam.endPoints)
  return &endpoints_;
}

// -------------------------------------------------------------------

// Proxy2Param

// string cluster_name = 1;
inline void Proxy2Param::clear_cluster_name() {
  cluster_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Proxy2Param::cluster_name() const {
  // @@protoc_insertion_point(field_get:cmongoproto.Proxy2Param.cluster_name)
  return cluster_name_.GetNoArena();
}
inline void Proxy2Param::set_cluster_name(const ::std::string& value) {
  
  cluster_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmongoproto.Proxy2Param.cluster_name)
}
#if LANG_CXX11
inline void Proxy2Param::set_cluster_name(::std::string&& value) {
  
  cluster_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmongoproto.Proxy2Param.cluster_name)
}
#endif
inline void Proxy2Param::set_cluster_name(const char* value) {
  
  cluster_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmongoproto.Proxy2Param.cluster_name)
}
inline void Proxy2Param::set_cluster_name(const char* value, size_t size) {
  
  cluster_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmongoproto.Proxy2Param.cluster_name)
}
inline ::std::string* Proxy2Param::mutable_cluster_name() {
  
  // @@protoc_insertion_point(field_mutable:cmongoproto.Proxy2Param.cluster_name)
  return cluster_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Proxy2Param::release_cluster_name() {
  // @@protoc_insertion_point(field_release:cmongoproto.Proxy2Param.cluster_name)
  
  return cluster_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Proxy2Param::set_allocated_cluster_name(::std::string* cluster_name) {
  if (cluster_name != NULL) {
    
  } else {
    
  }
  cluster_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cluster_name);
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.Proxy2Param.cluster_name)
}

// bool enable_shard = 2;
inline void Proxy2Param::clear_enable_shard() {
  enable_shard_ = false;
}
inline bool Proxy2Param::enable_shard() const {
  // @@protoc_insertion_point(field_get:cmongoproto.Proxy2Param.enable_shard)
  return enable_shard_;
}
inline void Proxy2Param::set_enable_shard(bool value) {
  
  enable_shard_ = value;
  // @@protoc_insertion_point(field_set:cmongoproto.Proxy2Param.enable_shard)
}

// repeated string endPoints = 3;
inline int Proxy2Param::endpoints_size() const {
  return endpoints_.size();
}
inline void Proxy2Param::clear_endpoints() {
  endpoints_.Clear();
}
inline const ::std::string& Proxy2Param::endpoints(int index) const {
  // @@protoc_insertion_point(field_get:cmongoproto.Proxy2Param.endPoints)
  return endpoints_.Get(index);
}
inline ::std::string* Proxy2Param::mutable_endpoints(int index) {
  // @@protoc_insertion_point(field_mutable:cmongoproto.Proxy2Param.endPoints)
  return endpoints_.Mutable(index);
}
inline void Proxy2Param::set_endpoints(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:cmongoproto.Proxy2Param.endPoints)
  endpoints_.Mutable(index)->assign(value);
}
inline void Proxy2Param::set_endpoints(int index, const char* value) {
  endpoints_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:cmongoproto.Proxy2Param.endPoints)
}
inline void Proxy2Param::set_endpoints(int index, const char* value, size_t size) {
  endpoints_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cmongoproto.Proxy2Param.endPoints)
}
inline ::std::string* Proxy2Param::add_endpoints() {
  // @@protoc_insertion_point(field_add_mutable:cmongoproto.Proxy2Param.endPoints)
  return endpoints_.Add();
}
inline void Proxy2Param::add_endpoints(const ::std::string& value) {
  endpoints_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:cmongoproto.Proxy2Param.endPoints)
}
inline void Proxy2Param::add_endpoints(const char* value) {
  endpoints_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:cmongoproto.Proxy2Param.endPoints)
}
inline void Proxy2Param::add_endpoints(const char* value, size_t size) {
  endpoints_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:cmongoproto.Proxy2Param.endPoints)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Proxy2Param::endpoints() const {
  // @@protoc_insertion_point(field_list:cmongoproto.Proxy2Param.endPoints)
  return endpoints_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Proxy2Param::mutable_endpoints() {
  // @@protoc_insertion_point(field_mutable_list:cmongoproto.Proxy2Param.endPoints)
  return &endpoints_;
}

// -------------------------------------------------------------------

// DynamoProxyParam

// string cluster_name = 1;
inline void DynamoProxyParam::clear_cluster_name() {
  cluster_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DynamoProxyParam::cluster_name() const {
  // @@protoc_insertion_point(field_get:cmongoproto.DynamoProxyParam.cluster_name)
  return cluster_name_.GetNoArena();
}
inline void DynamoProxyParam::set_cluster_name(const ::std::string& value) {
  
  cluster_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmongoproto.DynamoProxyParam.cluster_name)
}
#if LANG_CXX11
inline void DynamoProxyParam::set_cluster_name(::std::string&& value) {
  
  cluster_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmongoproto.DynamoProxyParam.cluster_name)
}
#endif
inline void DynamoProxyParam::set_cluster_name(const char* value) {
  
  cluster_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmongoproto.DynamoProxyParam.cluster_name)
}
inline void DynamoProxyParam::set_cluster_name(const char* value, size_t size) {
  
  cluster_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmongoproto.DynamoProxyParam.cluster_name)
}
inline ::std::string* DynamoProxyParam::mutable_cluster_name() {
  
  // @@protoc_insertion_point(field_mutable:cmongoproto.DynamoProxyParam.cluster_name)
  return cluster_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DynamoProxyParam::release_cluster_name() {
  // @@protoc_insertion_point(field_release:cmongoproto.DynamoProxyParam.cluster_name)
  
  return cluster_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DynamoProxyParam::set_allocated_cluster_name(::std::string* cluster_name) {
  if (cluster_name != NULL) {
    
  } else {
    
  }
  cluster_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cluster_name);
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.DynamoProxyParam.cluster_name)
}

// repeated string endPoints = 2;
inline int DynamoProxyParam::endpoints_size() const {
  return endpoints_.size();
}
inline void DynamoProxyParam::clear_endpoints() {
  endpoints_.Clear();
}
inline const ::std::string& DynamoProxyParam::endpoints(int index) const {
  // @@protoc_insertion_point(field_get:cmongoproto.DynamoProxyParam.endPoints)
  return endpoints_.Get(index);
}
inline ::std::string* DynamoProxyParam::mutable_endpoints(int index) {
  // @@protoc_insertion_point(field_mutable:cmongoproto.DynamoProxyParam.endPoints)
  return endpoints_.Mutable(index);
}
inline void DynamoProxyParam::set_endpoints(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:cmongoproto.DynamoProxyParam.endPoints)
  endpoints_.Mutable(index)->assign(value);
}
inline void DynamoProxyParam::set_endpoints(int index, const char* value) {
  endpoints_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:cmongoproto.DynamoProxyParam.endPoints)
}
inline void DynamoProxyParam::set_endpoints(int index, const char* value, size_t size) {
  endpoints_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cmongoproto.DynamoProxyParam.endPoints)
}
inline ::std::string* DynamoProxyParam::add_endpoints() {
  // @@protoc_insertion_point(field_add_mutable:cmongoproto.DynamoProxyParam.endPoints)
  return endpoints_.Add();
}
inline void DynamoProxyParam::add_endpoints(const ::std::string& value) {
  endpoints_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:cmongoproto.DynamoProxyParam.endPoints)
}
inline void DynamoProxyParam::add_endpoints(const char* value) {
  endpoints_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:cmongoproto.DynamoProxyParam.endPoints)
}
inline void DynamoProxyParam::add_endpoints(const char* value, size_t size) {
  endpoints_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:cmongoproto.DynamoProxyParam.endPoints)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DynamoProxyParam::endpoints() const {
  // @@protoc_insertion_point(field_list:cmongoproto.DynamoProxyParam.endPoints)
  return endpoints_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DynamoProxyParam::mutable_endpoints() {
  // @@protoc_insertion_point(field_mutable_list:cmongoproto.DynamoProxyParam.endPoints)
  return &endpoints_;
}

// -------------------------------------------------------------------

// CreateContainerReq

// .cmongoproto.ReqHeader header = 1;
inline bool CreateContainerReq::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void CreateContainerReq::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::cmongoproto::ReqHeader& CreateContainerReq::header() const {
  // @@protoc_insertion_point(field_get:cmongoproto.CreateContainerReq.header)
  return header_ != NULL ? *header_
                         : *::cmongoproto::ReqHeader::internal_default_instance();
}
inline ::cmongoproto::ReqHeader* CreateContainerReq::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::cmongoproto::ReqHeader;
  }
  // @@protoc_insertion_point(field_mutable:cmongoproto.CreateContainerReq.header)
  return header_;
}
inline ::cmongoproto::ReqHeader* CreateContainerReq::release_header() {
  // @@protoc_insertion_point(field_release:cmongoproto.CreateContainerReq.header)
  
  ::cmongoproto::ReqHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void CreateContainerReq::set_allocated_header(::cmongoproto::ReqHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.CreateContainerReq.header)
}

// int32 container_id = 2;
inline void CreateContainerReq::clear_container_id() {
  container_id_ = 0;
}
inline ::google::protobuf::int32 CreateContainerReq::container_id() const {
  // @@protoc_insertion_point(field_get:cmongoproto.CreateContainerReq.container_id)
  return container_id_;
}
inline void CreateContainerReq::set_container_id(::google::protobuf::int32 value) {
  
  container_id_ = value;
  // @@protoc_insertion_point(field_set:cmongoproto.CreateContainerReq.container_id)
}

// .cmongoproto.MongoType container_type = 3;
inline void CreateContainerReq::clear_container_type() {
  container_type_ = 0;
}
inline ::cmongoproto::MongoType CreateContainerReq::container_type() const {
  // @@protoc_insertion_point(field_get:cmongoproto.CreateContainerReq.container_type)
  return static_cast< ::cmongoproto::MongoType >(container_type_);
}
inline void CreateContainerReq::set_container_type(::cmongoproto::MongoType value) {
  
  container_type_ = value;
  // @@protoc_insertion_point(field_set:cmongoproto.CreateContainerReq.container_type)
}

// .cmongoproto.ResourceDesc quota = 4;
inline bool CreateContainerReq::has_quota() const {
  return this != internal_default_instance() && quota_ != NULL;
}
inline void CreateContainerReq::clear_quota() {
  if (GetArenaNoVirtual() == NULL && quota_ != NULL) delete quota_;
  quota_ = NULL;
}
inline const ::cmongoproto::ResourceDesc& CreateContainerReq::quota() const {
  // @@protoc_insertion_point(field_get:cmongoproto.CreateContainerReq.quota)
  return quota_ != NULL ? *quota_
                         : *::cmongoproto::ResourceDesc::internal_default_instance();
}
inline ::cmongoproto::ResourceDesc* CreateContainerReq::mutable_quota() {
  
  if (quota_ == NULL) {
    quota_ = new ::cmongoproto::ResourceDesc;
  }
  // @@protoc_insertion_point(field_mutable:cmongoproto.CreateContainerReq.quota)
  return quota_;
}
inline ::cmongoproto::ResourceDesc* CreateContainerReq::release_quota() {
  // @@protoc_insertion_point(field_release:cmongoproto.CreateContainerReq.quota)
  
  ::cmongoproto::ResourceDesc* temp = quota_;
  quota_ = NULL;
  return temp;
}
inline void CreateContainerReq::set_allocated_quota(::cmongoproto::ResourceDesc* quota) {
  delete quota_;
  quota_ = quota;
  if (quota) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.CreateContainerReq.quota)
}

// .cmongoproto.MongoVersion mongo_version = 5;
inline void CreateContainerReq::clear_mongo_version() {
  mongo_version_ = 0;
}
inline ::cmongoproto::MongoVersion CreateContainerReq::mongo_version() const {
  // @@protoc_insertion_point(field_get:cmongoproto.CreateContainerReq.mongo_version)
  return static_cast< ::cmongoproto::MongoVersion >(mongo_version_);
}
inline void CreateContainerReq::set_mongo_version(::cmongoproto::MongoVersion value) {
  
  mongo_version_ = value;
  // @@protoc_insertion_point(field_set:cmongoproto.CreateContainerReq.mongo_version)
}

// .cmongoproto.MongoDParam mongod_params = 6;
inline bool CreateContainerReq::has_mongod_params() const {
  return container_param_case() == kMongodParams;
}
inline void CreateContainerReq::set_has_mongod_params() {
  _oneof_case_[0] = kMongodParams;
}
inline void CreateContainerReq::clear_mongod_params() {
  if (has_mongod_params()) {
    delete container_param_.mongod_params_;
    clear_has_container_param();
  }
}
inline  const ::cmongoproto::MongoDParam& CreateContainerReq::mongod_params() const {
  // @@protoc_insertion_point(field_get:cmongoproto.CreateContainerReq.mongod_params)
  return has_mongod_params()
      ? *container_param_.mongod_params_
      : ::cmongoproto::MongoDParam::default_instance();
}
inline ::cmongoproto::MongoDParam* CreateContainerReq::mutable_mongod_params() {
  if (!has_mongod_params()) {
    clear_container_param();
    set_has_mongod_params();
    container_param_.mongod_params_ = new ::cmongoproto::MongoDParam;
  }
  // @@protoc_insertion_point(field_mutable:cmongoproto.CreateContainerReq.mongod_params)
  return container_param_.mongod_params_;
}
inline ::cmongoproto::MongoDParam* CreateContainerReq::release_mongod_params() {
  // @@protoc_insertion_point(field_release:cmongoproto.CreateContainerReq.mongod_params)
  if (has_mongod_params()) {
    clear_has_container_param();
    ::cmongoproto::MongoDParam* temp = container_param_.mongod_params_;
    container_param_.mongod_params_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void CreateContainerReq::set_allocated_mongod_params(::cmongoproto::MongoDParam* mongod_params) {
  clear_container_param();
  if (mongod_params) {
    set_has_mongod_params();
    container_param_.mongod_params_ = mongod_params;
  }
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.CreateContainerReq.mongod_params)
}

// .cmongoproto.MongoSParam mongos_params = 7;
inline bool CreateContainerReq::has_mongos_params() const {
  return container_param_case() == kMongosParams;
}
inline void CreateContainerReq::set_has_mongos_params() {
  _oneof_case_[0] = kMongosParams;
}
inline void CreateContainerReq::clear_mongos_params() {
  if (has_mongos_params()) {
    delete container_param_.mongos_params_;
    clear_has_container_param();
  }
}
inline  const ::cmongoproto::MongoSParam& CreateContainerReq::mongos_params() const {
  // @@protoc_insertion_point(field_get:cmongoproto.CreateContainerReq.mongos_params)
  return has_mongos_params()
      ? *container_param_.mongos_params_
      : ::cmongoproto::MongoSParam::default_instance();
}
inline ::cmongoproto::MongoSParam* CreateContainerReq::mutable_mongos_params() {
  if (!has_mongos_params()) {
    clear_container_param();
    set_has_mongos_params();
    container_param_.mongos_params_ = new ::cmongoproto::MongoSParam;
  }
  // @@protoc_insertion_point(field_mutable:cmongoproto.CreateContainerReq.mongos_params)
  return container_param_.mongos_params_;
}
inline ::cmongoproto::MongoSParam* CreateContainerReq::release_mongos_params() {
  // @@protoc_insertion_point(field_release:cmongoproto.CreateContainerReq.mongos_params)
  if (has_mongos_params()) {
    clear_has_container_param();
    ::cmongoproto::MongoSParam* temp = container_param_.mongos_params_;
    container_param_.mongos_params_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void CreateContainerReq::set_allocated_mongos_params(::cmongoproto::MongoSParam* mongos_params) {
  clear_container_param();
  if (mongos_params) {
    set_has_mongos_params();
    container_param_.mongos_params_ = mongos_params;
  }
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.CreateContainerReq.mongos_params)
}

// .cmongoproto.ConfigParam config_params = 8;
inline bool CreateContainerReq::has_config_params() const {
  return container_param_case() == kConfigParams;
}
inline void CreateContainerReq::set_has_config_params() {
  _oneof_case_[0] = kConfigParams;
}
inline void CreateContainerReq::clear_config_params() {
  if (has_config_params()) {
    delete container_param_.config_params_;
    clear_has_container_param();
  }
}
inline  const ::cmongoproto::ConfigParam& CreateContainerReq::config_params() const {
  // @@protoc_insertion_point(field_get:cmongoproto.CreateContainerReq.config_params)
  return has_config_params()
      ? *container_param_.config_params_
      : ::cmongoproto::ConfigParam::default_instance();
}
inline ::cmongoproto::ConfigParam* CreateContainerReq::mutable_config_params() {
  if (!has_config_params()) {
    clear_container_param();
    set_has_config_params();
    container_param_.config_params_ = new ::cmongoproto::ConfigParam;
  }
  // @@protoc_insertion_point(field_mutable:cmongoproto.CreateContainerReq.config_params)
  return container_param_.config_params_;
}
inline ::cmongoproto::ConfigParam* CreateContainerReq::release_config_params() {
  // @@protoc_insertion_point(field_release:cmongoproto.CreateContainerReq.config_params)
  if (has_config_params()) {
    clear_has_container_param();
    ::cmongoproto::ConfigParam* temp = container_param_.config_params_;
    container_param_.config_params_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void CreateContainerReq::set_allocated_config_params(::cmongoproto::ConfigParam* config_params) {
  clear_container_param();
  if (config_params) {
    set_has_config_params();
    container_param_.config_params_ = config_params;
  }
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.CreateContainerReq.config_params)
}

// .cmongoproto.ProxyParam proxy_params = 9;
inline bool CreateContainerReq::has_proxy_params() const {
  return container_param_case() == kProxyParams;
}
inline void CreateContainerReq::set_has_proxy_params() {
  _oneof_case_[0] = kProxyParams;
}
inline void CreateContainerReq::clear_proxy_params() {
  if (has_proxy_params()) {
    delete container_param_.proxy_params_;
    clear_has_container_param();
  }
}
inline  const ::cmongoproto::ProxyParam& CreateContainerReq::proxy_params() const {
  // @@protoc_insertion_point(field_get:cmongoproto.CreateContainerReq.proxy_params)
  return has_proxy_params()
      ? *container_param_.proxy_params_
      : ::cmongoproto::ProxyParam::default_instance();
}
inline ::cmongoproto::ProxyParam* CreateContainerReq::mutable_proxy_params() {
  if (!has_proxy_params()) {
    clear_container_param();
    set_has_proxy_params();
    container_param_.proxy_params_ = new ::cmongoproto::ProxyParam;
  }
  // @@protoc_insertion_point(field_mutable:cmongoproto.CreateContainerReq.proxy_params)
  return container_param_.proxy_params_;
}
inline ::cmongoproto::ProxyParam* CreateContainerReq::release_proxy_params() {
  // @@protoc_insertion_point(field_release:cmongoproto.CreateContainerReq.proxy_params)
  if (has_proxy_params()) {
    clear_has_container_param();
    ::cmongoproto::ProxyParam* temp = container_param_.proxy_params_;
    container_param_.proxy_params_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void CreateContainerReq::set_allocated_proxy_params(::cmongoproto::ProxyParam* proxy_params) {
  clear_container_param();
  if (proxy_params) {
    set_has_proxy_params();
    container_param_.proxy_params_ = proxy_params;
  }
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.CreateContainerReq.proxy_params)
}

// .cmongoproto.Proxy2Param proxy2_params = 10;
inline bool CreateContainerReq::has_proxy2_params() const {
  return container_param_case() == kProxy2Params;
}
inline void CreateContainerReq::set_has_proxy2_params() {
  _oneof_case_[0] = kProxy2Params;
}
inline void CreateContainerReq::clear_proxy2_params() {
  if (has_proxy2_params()) {
    delete container_param_.proxy2_params_;
    clear_has_container_param();
  }
}
inline  const ::cmongoproto::Proxy2Param& CreateContainerReq::proxy2_params() const {
  // @@protoc_insertion_point(field_get:cmongoproto.CreateContainerReq.proxy2_params)
  return has_proxy2_params()
      ? *container_param_.proxy2_params_
      : ::cmongoproto::Proxy2Param::default_instance();
}
inline ::cmongoproto::Proxy2Param* CreateContainerReq::mutable_proxy2_params() {
  if (!has_proxy2_params()) {
    clear_container_param();
    set_has_proxy2_params();
    container_param_.proxy2_params_ = new ::cmongoproto::Proxy2Param;
  }
  // @@protoc_insertion_point(field_mutable:cmongoproto.CreateContainerReq.proxy2_params)
  return container_param_.proxy2_params_;
}
inline ::cmongoproto::Proxy2Param* CreateContainerReq::release_proxy2_params() {
  // @@protoc_insertion_point(field_release:cmongoproto.CreateContainerReq.proxy2_params)
  if (has_proxy2_params()) {
    clear_has_container_param();
    ::cmongoproto::Proxy2Param* temp = container_param_.proxy2_params_;
    container_param_.proxy2_params_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void CreateContainerReq::set_allocated_proxy2_params(::cmongoproto::Proxy2Param* proxy2_params) {
  clear_container_param();
  if (proxy2_params) {
    set_has_proxy2_params();
    container_param_.proxy2_params_ = proxy2_params;
  }
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.CreateContainerReq.proxy2_params)
}

// .cmongoproto.DynamoProxyParam dynamo_params = 11;
inline bool CreateContainerReq::has_dynamo_params() const {
  return container_param_case() == kDynamoParams;
}
inline void CreateContainerReq::set_has_dynamo_params() {
  _oneof_case_[0] = kDynamoParams;
}
inline void CreateContainerReq::clear_dynamo_params() {
  if (has_dynamo_params()) {
    delete container_param_.dynamo_params_;
    clear_has_container_param();
  }
}
inline  const ::cmongoproto::DynamoProxyParam& CreateContainerReq::dynamo_params() const {
  // @@protoc_insertion_point(field_get:cmongoproto.CreateContainerReq.dynamo_params)
  return has_dynamo_params()
      ? *container_param_.dynamo_params_
      : ::cmongoproto::DynamoProxyParam::default_instance();
}
inline ::cmongoproto::DynamoProxyParam* CreateContainerReq::mutable_dynamo_params() {
  if (!has_dynamo_params()) {
    clear_container_param();
    set_has_dynamo_params();
    container_param_.dynamo_params_ = new ::cmongoproto::DynamoProxyParam;
  }
  // @@protoc_insertion_point(field_mutable:cmongoproto.CreateContainerReq.dynamo_params)
  return container_param_.dynamo_params_;
}
inline ::cmongoproto::DynamoProxyParam* CreateContainerReq::release_dynamo_params() {
  // @@protoc_insertion_point(field_release:cmongoproto.CreateContainerReq.dynamo_params)
  if (has_dynamo_params()) {
    clear_has_container_param();
    ::cmongoproto::DynamoProxyParam* temp = container_param_.dynamo_params_;
    container_param_.dynamo_params_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void CreateContainerReq::set_allocated_dynamo_params(::cmongoproto::DynamoProxyParam* dynamo_params) {
  clear_container_param();
  if (dynamo_params) {
    set_has_dynamo_params();
    container_param_.dynamo_params_ = dynamo_params;
  }
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.CreateContainerReq.dynamo_params)
}

// string proxy_version = 18;
inline void CreateContainerReq::clear_proxy_version() {
  proxy_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateContainerReq::proxy_version() const {
  // @@protoc_insertion_point(field_get:cmongoproto.CreateContainerReq.proxy_version)
  return proxy_version_.GetNoArena();
}
inline void CreateContainerReq::set_proxy_version(const ::std::string& value) {
  
  proxy_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmongoproto.CreateContainerReq.proxy_version)
}
#if LANG_CXX11
inline void CreateContainerReq::set_proxy_version(::std::string&& value) {
  
  proxy_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmongoproto.CreateContainerReq.proxy_version)
}
#endif
inline void CreateContainerReq::set_proxy_version(const char* value) {
  
  proxy_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmongoproto.CreateContainerReq.proxy_version)
}
inline void CreateContainerReq::set_proxy_version(const char* value, size_t size) {
  
  proxy_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmongoproto.CreateContainerReq.proxy_version)
}
inline ::std::string* CreateContainerReq::mutable_proxy_version() {
  
  // @@protoc_insertion_point(field_mutable:cmongoproto.CreateContainerReq.proxy_version)
  return proxy_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateContainerReq::release_proxy_version() {
  // @@protoc_insertion_point(field_release:cmongoproto.CreateContainerReq.proxy_version)
  
  return proxy_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateContainerReq::set_allocated_proxy_version(::std::string* proxy_version) {
  if (proxy_version != NULL) {
    
  } else {
    
  }
  proxy_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), proxy_version);
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.CreateContainerReq.proxy_version)
}

// string mongod_subversion = 19;
inline void CreateContainerReq::clear_mongod_subversion() {
  mongod_subversion_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateContainerReq::mongod_subversion() const {
  // @@protoc_insertion_point(field_get:cmongoproto.CreateContainerReq.mongod_subversion)
  return mongod_subversion_.GetNoArena();
}
inline void CreateContainerReq::set_mongod_subversion(const ::std::string& value) {
  
  mongod_subversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmongoproto.CreateContainerReq.mongod_subversion)
}
#if LANG_CXX11
inline void CreateContainerReq::set_mongod_subversion(::std::string&& value) {
  
  mongod_subversion_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmongoproto.CreateContainerReq.mongod_subversion)
}
#endif
inline void CreateContainerReq::set_mongod_subversion(const char* value) {
  
  mongod_subversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmongoproto.CreateContainerReq.mongod_subversion)
}
inline void CreateContainerReq::set_mongod_subversion(const char* value, size_t size) {
  
  mongod_subversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmongoproto.CreateContainerReq.mongod_subversion)
}
inline ::std::string* CreateContainerReq::mutable_mongod_subversion() {
  
  // @@protoc_insertion_point(field_mutable:cmongoproto.CreateContainerReq.mongod_subversion)
  return mongod_subversion_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateContainerReq::release_mongod_subversion() {
  // @@protoc_insertion_point(field_release:cmongoproto.CreateContainerReq.mongod_subversion)
  
  return mongod_subversion_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateContainerReq::set_allocated_mongod_subversion(::std::string* mongod_subversion) {
  if (mongod_subversion != NULL) {
    
  } else {
    
  }
  mongod_subversion_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mongod_subversion);
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.CreateContainerReq.mongod_subversion)
}

// string dynamo_proxy_version = 20;
inline void CreateContainerReq::clear_dynamo_proxy_version() {
  dynamo_proxy_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateContainerReq::dynamo_proxy_version() const {
  // @@protoc_insertion_point(field_get:cmongoproto.CreateContainerReq.dynamo_proxy_version)
  return dynamo_proxy_version_.GetNoArena();
}
inline void CreateContainerReq::set_dynamo_proxy_version(const ::std::string& value) {
  
  dynamo_proxy_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmongoproto.CreateContainerReq.dynamo_proxy_version)
}
#if LANG_CXX11
inline void CreateContainerReq::set_dynamo_proxy_version(::std::string&& value) {
  
  dynamo_proxy_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmongoproto.CreateContainerReq.dynamo_proxy_version)
}
#endif
inline void CreateContainerReq::set_dynamo_proxy_version(const char* value) {
  
  dynamo_proxy_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmongoproto.CreateContainerReq.dynamo_proxy_version)
}
inline void CreateContainerReq::set_dynamo_proxy_version(const char* value, size_t size) {
  
  dynamo_proxy_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmongoproto.CreateContainerReq.dynamo_proxy_version)
}
inline ::std::string* CreateContainerReq::mutable_dynamo_proxy_version() {
  
  // @@protoc_insertion_point(field_mutable:cmongoproto.CreateContainerReq.dynamo_proxy_version)
  return dynamo_proxy_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateContainerReq::release_dynamo_proxy_version() {
  // @@protoc_insertion_point(field_release:cmongoproto.CreateContainerReq.dynamo_proxy_version)
  
  return dynamo_proxy_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateContainerReq::set_allocated_dynamo_proxy_version(::std::string* dynamo_proxy_version) {
  if (dynamo_proxy_version != NULL) {
    
  } else {
    
  }
  dynamo_proxy_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dynamo_proxy_version);
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.CreateContainerReq.dynamo_proxy_version)
}

// string package_url = 21;
inline void CreateContainerReq::clear_package_url() {
  package_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateContainerReq::package_url() const {
  // @@protoc_insertion_point(field_get:cmongoproto.CreateContainerReq.package_url)
  return package_url_.GetNoArena();
}
inline void CreateContainerReq::set_package_url(const ::std::string& value) {
  
  package_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmongoproto.CreateContainerReq.package_url)
}
#if LANG_CXX11
inline void CreateContainerReq::set_package_url(::std::string&& value) {
  
  package_url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmongoproto.CreateContainerReq.package_url)
}
#endif
inline void CreateContainerReq::set_package_url(const char* value) {
  
  package_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmongoproto.CreateContainerReq.package_url)
}
inline void CreateContainerReq::set_package_url(const char* value, size_t size) {
  
  package_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmongoproto.CreateContainerReq.package_url)
}
inline ::std::string* CreateContainerReq::mutable_package_url() {
  
  // @@protoc_insertion_point(field_mutable:cmongoproto.CreateContainerReq.package_url)
  return package_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateContainerReq::release_package_url() {
  // @@protoc_insertion_point(field_release:cmongoproto.CreateContainerReq.package_url)
  
  return package_url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateContainerReq::set_allocated_package_url(::std::string* package_url) {
  if (package_url != NULL) {
    
  } else {
    
  }
  package_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), package_url);
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.CreateContainerReq.package_url)
}

// string user_password = 22;
inline void CreateContainerReq::clear_user_password() {
  user_password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateContainerReq::user_password() const {
  // @@protoc_insertion_point(field_get:cmongoproto.CreateContainerReq.user_password)
  return user_password_.GetNoArena();
}
inline void CreateContainerReq::set_user_password(const ::std::string& value) {
  
  user_password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmongoproto.CreateContainerReq.user_password)
}
#if LANG_CXX11
inline void CreateContainerReq::set_user_password(::std::string&& value) {
  
  user_password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmongoproto.CreateContainerReq.user_password)
}
#endif
inline void CreateContainerReq::set_user_password(const char* value) {
  
  user_password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmongoproto.CreateContainerReq.user_password)
}
inline void CreateContainerReq::set_user_password(const char* value, size_t size) {
  
  user_password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmongoproto.CreateContainerReq.user_password)
}
inline ::std::string* CreateContainerReq::mutable_user_password() {
  
  // @@protoc_insertion_point(field_mutable:cmongoproto.CreateContainerReq.user_password)
  return user_password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateContainerReq::release_user_password() {
  // @@protoc_insertion_point(field_release:cmongoproto.CreateContainerReq.user_password)
  
  return user_password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateContainerReq::set_allocated_user_password(::std::string* user_password) {
  if (user_password != NULL) {
    
  } else {
    
  }
  user_password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_password);
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.CreateContainerReq.user_password)
}

inline bool CreateContainerReq::has_container_param() const {
  return container_param_case() != CONTAINER_PARAM_NOT_SET;
}
inline void CreateContainerReq::clear_has_container_param() {
  _oneof_case_[0] = CONTAINER_PARAM_NOT_SET;
}
inline CreateContainerReq::ContainerParamCase CreateContainerReq::container_param_case() const {
  return CreateContainerReq::ContainerParamCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// PingReq

// .cmongoproto.ReqHeader header = 1;
inline bool PingReq::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void PingReq::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::cmongoproto::ReqHeader& PingReq::header() const {
  // @@protoc_insertion_point(field_get:cmongoproto.PingReq.header)
  return header_ != NULL ? *header_
                         : *::cmongoproto::ReqHeader::internal_default_instance();
}
inline ::cmongoproto::ReqHeader* PingReq::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::cmongoproto::ReqHeader;
  }
  // @@protoc_insertion_point(field_mutable:cmongoproto.PingReq.header)
  return header_;
}
inline ::cmongoproto::ReqHeader* PingReq::release_header() {
  // @@protoc_insertion_point(field_release:cmongoproto.PingReq.header)
  
  ::cmongoproto::ReqHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void PingReq::set_allocated_header(::cmongoproto::ReqHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.PingReq.header)
}

// -------------------------------------------------------------------

// PingRes

// .cmongoproto.ResHeader header = 1;
inline bool PingRes::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void PingRes::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::cmongoproto::ResHeader& PingRes::header() const {
  // @@protoc_insertion_point(field_get:cmongoproto.PingRes.header)
  return header_ != NULL ? *header_
                         : *::cmongoproto::ResHeader::internal_default_instance();
}
inline ::cmongoproto::ResHeader* PingRes::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::cmongoproto::ResHeader;
  }
  // @@protoc_insertion_point(field_mutable:cmongoproto.PingRes.header)
  return header_;
}
inline ::cmongoproto::ResHeader* PingRes::release_header() {
  // @@protoc_insertion_point(field_release:cmongoproto.PingRes.header)
  
  ::cmongoproto::ResHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void PingRes::set_allocated_header(::cmongoproto::ResHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.PingRes.header)
}

// -------------------------------------------------------------------

// CreateContainerRes

// .cmongoproto.ResHeader header = 1;
inline bool CreateContainerRes::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void CreateContainerRes::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::cmongoproto::ResHeader& CreateContainerRes::header() const {
  // @@protoc_insertion_point(field_get:cmongoproto.CreateContainerRes.header)
  return header_ != NULL ? *header_
                         : *::cmongoproto::ResHeader::internal_default_instance();
}
inline ::cmongoproto::ResHeader* CreateContainerRes::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::cmongoproto::ResHeader;
  }
  // @@protoc_insertion_point(field_mutable:cmongoproto.CreateContainerRes.header)
  return header_;
}
inline ::cmongoproto::ResHeader* CreateContainerRes::release_header() {
  // @@protoc_insertion_point(field_release:cmongoproto.CreateContainerRes.header)
  
  ::cmongoproto::ResHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void CreateContainerRes::set_allocated_header(::cmongoproto::ResHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.CreateContainerRes.header)
}

// int32 port_used = 2;
inline void CreateContainerRes::clear_port_used() {
  port_used_ = 0;
}
inline ::google::protobuf::int32 CreateContainerRes::port_used() const {
  // @@protoc_insertion_point(field_get:cmongoproto.CreateContainerRes.port_used)
  return port_used_;
}
inline void CreateContainerRes::set_port_used(::google::protobuf::int32 value) {
  
  port_used_ = value;
  // @@protoc_insertion_point(field_set:cmongoproto.CreateContainerRes.port_used)
}

// -------------------------------------------------------------------

// DestroyContainerReq

// .cmongoproto.ReqHeader header = 1;
inline bool DestroyContainerReq::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DestroyContainerReq::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::cmongoproto::ReqHeader& DestroyContainerReq::header() const {
  // @@protoc_insertion_point(field_get:cmongoproto.DestroyContainerReq.header)
  return header_ != NULL ? *header_
                         : *::cmongoproto::ReqHeader::internal_default_instance();
}
inline ::cmongoproto::ReqHeader* DestroyContainerReq::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::cmongoproto::ReqHeader;
  }
  // @@protoc_insertion_point(field_mutable:cmongoproto.DestroyContainerReq.header)
  return header_;
}
inline ::cmongoproto::ReqHeader* DestroyContainerReq::release_header() {
  // @@protoc_insertion_point(field_release:cmongoproto.DestroyContainerReq.header)
  
  ::cmongoproto::ReqHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DestroyContainerReq::set_allocated_header(::cmongoproto::ReqHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.DestroyContainerReq.header)
}

// int32 container_id = 2;
inline void DestroyContainerReq::clear_container_id() {
  container_id_ = 0;
}
inline ::google::protobuf::int32 DestroyContainerReq::container_id() const {
  // @@protoc_insertion_point(field_get:cmongoproto.DestroyContainerReq.container_id)
  return container_id_;
}
inline void DestroyContainerReq::set_container_id(::google::protobuf::int32 value) {
  
  container_id_ = value;
  // @@protoc_insertion_point(field_set:cmongoproto.DestroyContainerReq.container_id)
}

// -------------------------------------------------------------------

// DestroyContainerRes

// .cmongoproto.ResHeader header = 1;
inline bool DestroyContainerRes::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DestroyContainerRes::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::cmongoproto::ResHeader& DestroyContainerRes::header() const {
  // @@protoc_insertion_point(field_get:cmongoproto.DestroyContainerRes.header)
  return header_ != NULL ? *header_
                         : *::cmongoproto::ResHeader::internal_default_instance();
}
inline ::cmongoproto::ResHeader* DestroyContainerRes::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::cmongoproto::ResHeader;
  }
  // @@protoc_insertion_point(field_mutable:cmongoproto.DestroyContainerRes.header)
  return header_;
}
inline ::cmongoproto::ResHeader* DestroyContainerRes::release_header() {
  // @@protoc_insertion_point(field_release:cmongoproto.DestroyContainerRes.header)
  
  ::cmongoproto::ResHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DestroyContainerRes::set_allocated_header(::cmongoproto::ResHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.DestroyContainerRes.header)
}

// -------------------------------------------------------------------

// InfoContainerReq

// .cmongoproto.ReqHeader header = 1;
inline bool InfoContainerReq::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void InfoContainerReq::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::cmongoproto::ReqHeader& InfoContainerReq::header() const {
  // @@protoc_insertion_point(field_get:cmongoproto.InfoContainerReq.header)
  return header_ != NULL ? *header_
                         : *::cmongoproto::ReqHeader::internal_default_instance();
}
inline ::cmongoproto::ReqHeader* InfoContainerReq::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::cmongoproto::ReqHeader;
  }
  // @@protoc_insertion_point(field_mutable:cmongoproto.InfoContainerReq.header)
  return header_;
}
inline ::cmongoproto::ReqHeader* InfoContainerReq::release_header() {
  // @@protoc_insertion_point(field_release:cmongoproto.InfoContainerReq.header)
  
  ::cmongoproto::ReqHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void InfoContainerReq::set_allocated_header(::cmongoproto::ReqHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.InfoContainerReq.header)
}

// int32 container_id = 2;
inline void InfoContainerReq::clear_container_id() {
  container_id_ = 0;
}
inline ::google::protobuf::int32 InfoContainerReq::container_id() const {
  // @@protoc_insertion_point(field_get:cmongoproto.InfoContainerReq.container_id)
  return container_id_;
}
inline void InfoContainerReq::set_container_id(::google::protobuf::int32 value) {
  
  container_id_ = value;
  // @@protoc_insertion_point(field_set:cmongoproto.InfoContainerReq.container_id)
}

// -------------------------------------------------------------------

// InfoContainerRes

// .cmongoproto.ResHeader header = 1;
inline bool InfoContainerRes::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void InfoContainerRes::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::cmongoproto::ResHeader& InfoContainerRes::header() const {
  // @@protoc_insertion_point(field_get:cmongoproto.InfoContainerRes.header)
  return header_ != NULL ? *header_
                         : *::cmongoproto::ResHeader::internal_default_instance();
}
inline ::cmongoproto::ResHeader* InfoContainerRes::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::cmongoproto::ResHeader;
  }
  // @@protoc_insertion_point(field_mutable:cmongoproto.InfoContainerRes.header)
  return header_;
}
inline ::cmongoproto::ResHeader* InfoContainerRes::release_header() {
  // @@protoc_insertion_point(field_release:cmongoproto.InfoContainerRes.header)
  
  ::cmongoproto::ResHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void InfoContainerRes::set_allocated_header(::cmongoproto::ResHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.InfoContainerRes.header)
}

// .cmongoproto.ResourceDesc using = 2;
inline bool InfoContainerRes::has_using_() const {
  return this != internal_default_instance() && using__ != NULL;
}
inline void InfoContainerRes::clear_using_() {
  if (GetArenaNoVirtual() == NULL && using__ != NULL) delete using__;
  using__ = NULL;
}
inline const ::cmongoproto::ResourceDesc& InfoContainerRes::using_() const {
  // @@protoc_insertion_point(field_get:cmongoproto.InfoContainerRes.using)
  return using__ != NULL ? *using__
                         : *::cmongoproto::ResourceDesc::internal_default_instance();
}
inline ::cmongoproto::ResourceDesc* InfoContainerRes::mutable_using_() {
  
  if (using__ == NULL) {
    using__ = new ::cmongoproto::ResourceDesc;
  }
  // @@protoc_insertion_point(field_mutable:cmongoproto.InfoContainerRes.using)
  return using__;
}
inline ::cmongoproto::ResourceDesc* InfoContainerRes::release_using_() {
  // @@protoc_insertion_point(field_release:cmongoproto.InfoContainerRes.using)
  
  ::cmongoproto::ResourceDesc* temp = using__;
  using__ = NULL;
  return temp;
}
inline void InfoContainerRes::set_allocated_using_(::cmongoproto::ResourceDesc* using_) {
  delete using__;
  using__ = using_;
  if (using_) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.InfoContainerRes.using)
}

// -------------------------------------------------------------------

// StartContainerReq

// .cmongoproto.ReqHeader header = 1;
inline bool StartContainerReq::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void StartContainerReq::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::cmongoproto::ReqHeader& StartContainerReq::header() const {
  // @@protoc_insertion_point(field_get:cmongoproto.StartContainerReq.header)
  return header_ != NULL ? *header_
                         : *::cmongoproto::ReqHeader::internal_default_instance();
}
inline ::cmongoproto::ReqHeader* StartContainerReq::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::cmongoproto::ReqHeader;
  }
  // @@protoc_insertion_point(field_mutable:cmongoproto.StartContainerReq.header)
  return header_;
}
inline ::cmongoproto::ReqHeader* StartContainerReq::release_header() {
  // @@protoc_insertion_point(field_release:cmongoproto.StartContainerReq.header)
  
  ::cmongoproto::ReqHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void StartContainerReq::set_allocated_header(::cmongoproto::ReqHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.StartContainerReq.header)
}

// int32 container_id = 2;
inline void StartContainerReq::clear_container_id() {
  container_id_ = 0;
}
inline ::google::protobuf::int32 StartContainerReq::container_id() const {
  // @@protoc_insertion_point(field_get:cmongoproto.StartContainerReq.container_id)
  return container_id_;
}
inline void StartContainerReq::set_container_id(::google::protobuf::int32 value) {
  
  container_id_ = value;
  // @@protoc_insertion_point(field_set:cmongoproto.StartContainerReq.container_id)
}

// -------------------------------------------------------------------

// StartContainerRes

// .cmongoproto.ResHeader header = 1;
inline bool StartContainerRes::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void StartContainerRes::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::cmongoproto::ResHeader& StartContainerRes::header() const {
  // @@protoc_insertion_point(field_get:cmongoproto.StartContainerRes.header)
  return header_ != NULL ? *header_
                         : *::cmongoproto::ResHeader::internal_default_instance();
}
inline ::cmongoproto::ResHeader* StartContainerRes::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::cmongoproto::ResHeader;
  }
  // @@protoc_insertion_point(field_mutable:cmongoproto.StartContainerRes.header)
  return header_;
}
inline ::cmongoproto::ResHeader* StartContainerRes::release_header() {
  // @@protoc_insertion_point(field_release:cmongoproto.StartContainerRes.header)
  
  ::cmongoproto::ResHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void StartContainerRes::set_allocated_header(::cmongoproto::ResHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.StartContainerRes.header)
}

// -------------------------------------------------------------------

// RSInitReq

// .cmongoproto.ReqHeader header = 1;
inline bool RSInitReq::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void RSInitReq::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::cmongoproto::ReqHeader& RSInitReq::header() const {
  // @@protoc_insertion_point(field_get:cmongoproto.RSInitReq.header)
  return header_ != NULL ? *header_
                         : *::cmongoproto::ReqHeader::internal_default_instance();
}
inline ::cmongoproto::ReqHeader* RSInitReq::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::cmongoproto::ReqHeader;
  }
  // @@protoc_insertion_point(field_mutable:cmongoproto.RSInitReq.header)
  return header_;
}
inline ::cmongoproto::ReqHeader* RSInitReq::release_header() {
  // @@protoc_insertion_point(field_release:cmongoproto.RSInitReq.header)
  
  ::cmongoproto::ReqHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void RSInitReq::set_allocated_header(::cmongoproto::ReqHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.RSInitReq.header)
}

// int32 container_id = 2;
inline void RSInitReq::clear_container_id() {
  container_id_ = 0;
}
inline ::google::protobuf::int32 RSInitReq::container_id() const {
  // @@protoc_insertion_point(field_get:cmongoproto.RSInitReq.container_id)
  return container_id_;
}
inline void RSInitReq::set_container_id(::google::protobuf::int32 value) {
  
  container_id_ = value;
  // @@protoc_insertion_point(field_set:cmongoproto.RSInitReq.container_id)
}

// string rs_name = 3;
inline void RSInitReq::clear_rs_name() {
  rs_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RSInitReq::rs_name() const {
  // @@protoc_insertion_point(field_get:cmongoproto.RSInitReq.rs_name)
  return rs_name_.GetNoArena();
}
inline void RSInitReq::set_rs_name(const ::std::string& value) {
  
  rs_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmongoproto.RSInitReq.rs_name)
}
#if LANG_CXX11
inline void RSInitReq::set_rs_name(::std::string&& value) {
  
  rs_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmongoproto.RSInitReq.rs_name)
}
#endif
inline void RSInitReq::set_rs_name(const char* value) {
  
  rs_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmongoproto.RSInitReq.rs_name)
}
inline void RSInitReq::set_rs_name(const char* value, size_t size) {
  
  rs_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmongoproto.RSInitReq.rs_name)
}
inline ::std::string* RSInitReq::mutable_rs_name() {
  
  // @@protoc_insertion_point(field_mutable:cmongoproto.RSInitReq.rs_name)
  return rs_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RSInitReq::release_rs_name() {
  // @@protoc_insertion_point(field_release:cmongoproto.RSInitReq.rs_name)
  
  return rs_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RSInitReq::set_allocated_rs_name(::std::string* rs_name) {
  if (rs_name != NULL) {
    
  } else {
    
  }
  rs_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rs_name);
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.RSInitReq.rs_name)
}

// repeated string rs_ips = 4;
inline int RSInitReq::rs_ips_size() const {
  return rs_ips_.size();
}
inline void RSInitReq::clear_rs_ips() {
  rs_ips_.Clear();
}
inline const ::std::string& RSInitReq::rs_ips(int index) const {
  // @@protoc_insertion_point(field_get:cmongoproto.RSInitReq.rs_ips)
  return rs_ips_.Get(index);
}
inline ::std::string* RSInitReq::mutable_rs_ips(int index) {
  // @@protoc_insertion_point(field_mutable:cmongoproto.RSInitReq.rs_ips)
  return rs_ips_.Mutable(index);
}
inline void RSInitReq::set_rs_ips(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:cmongoproto.RSInitReq.rs_ips)
  rs_ips_.Mutable(index)->assign(value);
}
inline void RSInitReq::set_rs_ips(int index, const char* value) {
  rs_ips_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:cmongoproto.RSInitReq.rs_ips)
}
inline void RSInitReq::set_rs_ips(int index, const char* value, size_t size) {
  rs_ips_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cmongoproto.RSInitReq.rs_ips)
}
inline ::std::string* RSInitReq::add_rs_ips() {
  // @@protoc_insertion_point(field_add_mutable:cmongoproto.RSInitReq.rs_ips)
  return rs_ips_.Add();
}
inline void RSInitReq::add_rs_ips(const ::std::string& value) {
  rs_ips_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:cmongoproto.RSInitReq.rs_ips)
}
inline void RSInitReq::add_rs_ips(const char* value) {
  rs_ips_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:cmongoproto.RSInitReq.rs_ips)
}
inline void RSInitReq::add_rs_ips(const char* value, size_t size) {
  rs_ips_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:cmongoproto.RSInitReq.rs_ips)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RSInitReq::rs_ips() const {
  // @@protoc_insertion_point(field_list:cmongoproto.RSInitReq.rs_ips)
  return rs_ips_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RSInitReq::mutable_rs_ips() {
  // @@protoc_insertion_point(field_mutable_list:cmongoproto.RSInitReq.rs_ips)
  return &rs_ips_;
}

// -------------------------------------------------------------------

// RSInitRes

// .cmongoproto.ResHeader header = 1;
inline bool RSInitRes::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void RSInitRes::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::cmongoproto::ResHeader& RSInitRes::header() const {
  // @@protoc_insertion_point(field_get:cmongoproto.RSInitRes.header)
  return header_ != NULL ? *header_
                         : *::cmongoproto::ResHeader::internal_default_instance();
}
inline ::cmongoproto::ResHeader* RSInitRes::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::cmongoproto::ResHeader;
  }
  // @@protoc_insertion_point(field_mutable:cmongoproto.RSInitRes.header)
  return header_;
}
inline ::cmongoproto::ResHeader* RSInitRes::release_header() {
  // @@protoc_insertion_point(field_release:cmongoproto.RSInitRes.header)
  
  ::cmongoproto::ResHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void RSInitRes::set_allocated_header(::cmongoproto::ResHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.RSInitRes.header)
}

// -------------------------------------------------------------------

// RSStatusReq

// .cmongoproto.ReqHeader header = 1;
inline bool RSStatusReq::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void RSStatusReq::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::cmongoproto::ReqHeader& RSStatusReq::header() const {
  // @@protoc_insertion_point(field_get:cmongoproto.RSStatusReq.header)
  return header_ != NULL ? *header_
                         : *::cmongoproto::ReqHeader::internal_default_instance();
}
inline ::cmongoproto::ReqHeader* RSStatusReq::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::cmongoproto::ReqHeader;
  }
  // @@protoc_insertion_point(field_mutable:cmongoproto.RSStatusReq.header)
  return header_;
}
inline ::cmongoproto::ReqHeader* RSStatusReq::release_header() {
  // @@protoc_insertion_point(field_release:cmongoproto.RSStatusReq.header)
  
  ::cmongoproto::ReqHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void RSStatusReq::set_allocated_header(::cmongoproto::ReqHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.RSStatusReq.header)
}

// int32 container_id = 2;
inline void RSStatusReq::clear_container_id() {
  container_id_ = 0;
}
inline ::google::protobuf::int32 RSStatusReq::container_id() const {
  // @@protoc_insertion_point(field_get:cmongoproto.RSStatusReq.container_id)
  return container_id_;
}
inline void RSStatusReq::set_container_id(::google::protobuf::int32 value) {
  
  container_id_ = value;
  // @@protoc_insertion_point(field_set:cmongoproto.RSStatusReq.container_id)
}

// -------------------------------------------------------------------

// RSStatusRes

// .cmongoproto.ResHeader header = 1;
inline bool RSStatusRes::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void RSStatusRes::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::cmongoproto::ResHeader& RSStatusRes::header() const {
  // @@protoc_insertion_point(field_get:cmongoproto.RSStatusRes.header)
  return header_ != NULL ? *header_
                         : *::cmongoproto::ResHeader::internal_default_instance();
}
inline ::cmongoproto::ResHeader* RSStatusRes::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::cmongoproto::ResHeader;
  }
  // @@protoc_insertion_point(field_mutable:cmongoproto.RSStatusRes.header)
  return header_;
}
inline ::cmongoproto::ResHeader* RSStatusRes::release_header() {
  // @@protoc_insertion_point(field_release:cmongoproto.RSStatusRes.header)
  
  ::cmongoproto::ResHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void RSStatusRes::set_allocated_header(::cmongoproto::ResHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.RSStatusRes.header)
}

// string result = 2;
inline void RSStatusRes::clear_result() {
  result_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RSStatusRes::result() const {
  // @@protoc_insertion_point(field_get:cmongoproto.RSStatusRes.result)
  return result_.GetNoArena();
}
inline void RSStatusRes::set_result(const ::std::string& value) {
  
  result_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmongoproto.RSStatusRes.result)
}
#if LANG_CXX11
inline void RSStatusRes::set_result(::std::string&& value) {
  
  result_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmongoproto.RSStatusRes.result)
}
#endif
inline void RSStatusRes::set_result(const char* value) {
  
  result_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmongoproto.RSStatusRes.result)
}
inline void RSStatusRes::set_result(const char* value, size_t size) {
  
  result_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmongoproto.RSStatusRes.result)
}
inline ::std::string* RSStatusRes::mutable_result() {
  
  // @@protoc_insertion_point(field_mutable:cmongoproto.RSStatusRes.result)
  return result_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RSStatusRes::release_result() {
  // @@protoc_insertion_point(field_release:cmongoproto.RSStatusRes.result)
  
  return result_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RSStatusRes::set_allocated_result(::std::string* result) {
  if (result != NULL) {
    
  } else {
    
  }
  result_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), result);
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.RSStatusRes.result)
}

// -------------------------------------------------------------------

// RSAddReq

// .cmongoproto.ReqHeader header = 1;
inline bool RSAddReq::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void RSAddReq::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::cmongoproto::ReqHeader& RSAddReq::header() const {
  // @@protoc_insertion_point(field_get:cmongoproto.RSAddReq.header)
  return header_ != NULL ? *header_
                         : *::cmongoproto::ReqHeader::internal_default_instance();
}
inline ::cmongoproto::ReqHeader* RSAddReq::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::cmongoproto::ReqHeader;
  }
  // @@protoc_insertion_point(field_mutable:cmongoproto.RSAddReq.header)
  return header_;
}
inline ::cmongoproto::ReqHeader* RSAddReq::release_header() {
  // @@protoc_insertion_point(field_release:cmongoproto.RSAddReq.header)
  
  ::cmongoproto::ReqHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void RSAddReq::set_allocated_header(::cmongoproto::ReqHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.RSAddReq.header)
}

// int32 container_id = 2;
inline void RSAddReq::clear_container_id() {
  container_id_ = 0;
}
inline ::google::protobuf::int32 RSAddReq::container_id() const {
  // @@protoc_insertion_point(field_get:cmongoproto.RSAddReq.container_id)
  return container_id_;
}
inline void RSAddReq::set_container_id(::google::protobuf::int32 value) {
  
  container_id_ = value;
  // @@protoc_insertion_point(field_set:cmongoproto.RSAddReq.container_id)
}

// .cmongoproto.MemberType member_type = 3;
inline void RSAddReq::clear_member_type() {
  member_type_ = 0;
}
inline ::cmongoproto::MemberType RSAddReq::member_type() const {
  // @@protoc_insertion_point(field_get:cmongoproto.RSAddReq.member_type)
  return static_cast< ::cmongoproto::MemberType >(member_type_);
}
inline void RSAddReq::set_member_type(::cmongoproto::MemberType value) {
  
  member_type_ = value;
  // @@protoc_insertion_point(field_set:cmongoproto.RSAddReq.member_type)
}

// string member_ip = 4;
inline void RSAddReq::clear_member_ip() {
  member_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RSAddReq::member_ip() const {
  // @@protoc_insertion_point(field_get:cmongoproto.RSAddReq.member_ip)
  return member_ip_.GetNoArena();
}
inline void RSAddReq::set_member_ip(const ::std::string& value) {
  
  member_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmongoproto.RSAddReq.member_ip)
}
#if LANG_CXX11
inline void RSAddReq::set_member_ip(::std::string&& value) {
  
  member_ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmongoproto.RSAddReq.member_ip)
}
#endif
inline void RSAddReq::set_member_ip(const char* value) {
  
  member_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmongoproto.RSAddReq.member_ip)
}
inline void RSAddReq::set_member_ip(const char* value, size_t size) {
  
  member_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmongoproto.RSAddReq.member_ip)
}
inline ::std::string* RSAddReq::mutable_member_ip() {
  
  // @@protoc_insertion_point(field_mutable:cmongoproto.RSAddReq.member_ip)
  return member_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RSAddReq::release_member_ip() {
  // @@protoc_insertion_point(field_release:cmongoproto.RSAddReq.member_ip)
  
  return member_ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RSAddReq::set_allocated_member_ip(::std::string* member_ip) {
  if (member_ip != NULL) {
    
  } else {
    
  }
  member_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), member_ip);
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.RSAddReq.member_ip)
}

// -------------------------------------------------------------------

// RSAddRes

// .cmongoproto.ResHeader header = 1;
inline bool RSAddRes::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void RSAddRes::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::cmongoproto::ResHeader& RSAddRes::header() const {
  // @@protoc_insertion_point(field_get:cmongoproto.RSAddRes.header)
  return header_ != NULL ? *header_
                         : *::cmongoproto::ResHeader::internal_default_instance();
}
inline ::cmongoproto::ResHeader* RSAddRes::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::cmongoproto::ResHeader;
  }
  // @@protoc_insertion_point(field_mutable:cmongoproto.RSAddRes.header)
  return header_;
}
inline ::cmongoproto::ResHeader* RSAddRes::release_header() {
  // @@protoc_insertion_point(field_release:cmongoproto.RSAddRes.header)
  
  ::cmongoproto::ResHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void RSAddRes::set_allocated_header(::cmongoproto::ResHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.RSAddRes.header)
}

// -------------------------------------------------------------------

// RSRemoveReq

// .cmongoproto.ReqHeader header = 1;
inline bool RSRemoveReq::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void RSRemoveReq::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::cmongoproto::ReqHeader& RSRemoveReq::header() const {
  // @@protoc_insertion_point(field_get:cmongoproto.RSRemoveReq.header)
  return header_ != NULL ? *header_
                         : *::cmongoproto::ReqHeader::internal_default_instance();
}
inline ::cmongoproto::ReqHeader* RSRemoveReq::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::cmongoproto::ReqHeader;
  }
  // @@protoc_insertion_point(field_mutable:cmongoproto.RSRemoveReq.header)
  return header_;
}
inline ::cmongoproto::ReqHeader* RSRemoveReq::release_header() {
  // @@protoc_insertion_point(field_release:cmongoproto.RSRemoveReq.header)
  
  ::cmongoproto::ReqHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void RSRemoveReq::set_allocated_header(::cmongoproto::ReqHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.RSRemoveReq.header)
}

// int32 container_id = 2;
inline void RSRemoveReq::clear_container_id() {
  container_id_ = 0;
}
inline ::google::protobuf::int32 RSRemoveReq::container_id() const {
  // @@protoc_insertion_point(field_get:cmongoproto.RSRemoveReq.container_id)
  return container_id_;
}
inline void RSRemoveReq::set_container_id(::google::protobuf::int32 value) {
  
  container_id_ = value;
  // @@protoc_insertion_point(field_set:cmongoproto.RSRemoveReq.container_id)
}

// string member_ip = 3;
inline void RSRemoveReq::clear_member_ip() {
  member_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RSRemoveReq::member_ip() const {
  // @@protoc_insertion_point(field_get:cmongoproto.RSRemoveReq.member_ip)
  return member_ip_.GetNoArena();
}
inline void RSRemoveReq::set_member_ip(const ::std::string& value) {
  
  member_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmongoproto.RSRemoveReq.member_ip)
}
#if LANG_CXX11
inline void RSRemoveReq::set_member_ip(::std::string&& value) {
  
  member_ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmongoproto.RSRemoveReq.member_ip)
}
#endif
inline void RSRemoveReq::set_member_ip(const char* value) {
  
  member_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmongoproto.RSRemoveReq.member_ip)
}
inline void RSRemoveReq::set_member_ip(const char* value, size_t size) {
  
  member_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmongoproto.RSRemoveReq.member_ip)
}
inline ::std::string* RSRemoveReq::mutable_member_ip() {
  
  // @@protoc_insertion_point(field_mutable:cmongoproto.RSRemoveReq.member_ip)
  return member_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RSRemoveReq::release_member_ip() {
  // @@protoc_insertion_point(field_release:cmongoproto.RSRemoveReq.member_ip)
  
  return member_ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RSRemoveReq::set_allocated_member_ip(::std::string* member_ip) {
  if (member_ip != NULL) {
    
  } else {
    
  }
  member_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), member_ip);
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.RSRemoveReq.member_ip)
}

// -------------------------------------------------------------------

// RSRemoveRes

// .cmongoproto.ResHeader header = 1;
inline bool RSRemoveRes::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void RSRemoveRes::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::cmongoproto::ResHeader& RSRemoveRes::header() const {
  // @@protoc_insertion_point(field_get:cmongoproto.RSRemoveRes.header)
  return header_ != NULL ? *header_
                         : *::cmongoproto::ResHeader::internal_default_instance();
}
inline ::cmongoproto::ResHeader* RSRemoveRes::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::cmongoproto::ResHeader;
  }
  // @@protoc_insertion_point(field_mutable:cmongoproto.RSRemoveRes.header)
  return header_;
}
inline ::cmongoproto::ResHeader* RSRemoveRes::release_header() {
  // @@protoc_insertion_point(field_release:cmongoproto.RSRemoveRes.header)
  
  ::cmongoproto::ResHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void RSRemoveRes::set_allocated_header(::cmongoproto::ResHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.RSRemoveRes.header)
}

// -------------------------------------------------------------------

// StopContainerReq

// .cmongoproto.ReqHeader header = 1;
inline bool StopContainerReq::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void StopContainerReq::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::cmongoproto::ReqHeader& StopContainerReq::header() const {
  // @@protoc_insertion_point(field_get:cmongoproto.StopContainerReq.header)
  return header_ != NULL ? *header_
                         : *::cmongoproto::ReqHeader::internal_default_instance();
}
inline ::cmongoproto::ReqHeader* StopContainerReq::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::cmongoproto::ReqHeader;
  }
  // @@protoc_insertion_point(field_mutable:cmongoproto.StopContainerReq.header)
  return header_;
}
inline ::cmongoproto::ReqHeader* StopContainerReq::release_header() {
  // @@protoc_insertion_point(field_release:cmongoproto.StopContainerReq.header)
  
  ::cmongoproto::ReqHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void StopContainerReq::set_allocated_header(::cmongoproto::ReqHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.StopContainerReq.header)
}

// int32 container_id = 2;
inline void StopContainerReq::clear_container_id() {
  container_id_ = 0;
}
inline ::google::protobuf::int32 StopContainerReq::container_id() const {
  // @@protoc_insertion_point(field_get:cmongoproto.StopContainerReq.container_id)
  return container_id_;
}
inline void StopContainerReq::set_container_id(::google::protobuf::int32 value) {
  
  container_id_ = value;
  // @@protoc_insertion_point(field_set:cmongoproto.StopContainerReq.container_id)
}

// -------------------------------------------------------------------

// StopContainerRes

// .cmongoproto.ResHeader header = 1;
inline bool StopContainerRes::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void StopContainerRes::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::cmongoproto::ResHeader& StopContainerRes::header() const {
  // @@protoc_insertion_point(field_get:cmongoproto.StopContainerRes.header)
  return header_ != NULL ? *header_
                         : *::cmongoproto::ResHeader::internal_default_instance();
}
inline ::cmongoproto::ResHeader* StopContainerRes::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::cmongoproto::ResHeader;
  }
  // @@protoc_insertion_point(field_mutable:cmongoproto.StopContainerRes.header)
  return header_;
}
inline ::cmongoproto::ResHeader* StopContainerRes::release_header() {
  // @@protoc_insertion_point(field_release:cmongoproto.StopContainerRes.header)
  
  ::cmongoproto::ResHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void StopContainerRes::set_allocated_header(::cmongoproto::ResHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.StopContainerRes.header)
}

// -------------------------------------------------------------------

// CommandContainerReq

// .cmongoproto.ReqHeader header = 1;
inline bool CommandContainerReq::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void CommandContainerReq::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::cmongoproto::ReqHeader& CommandContainerReq::header() const {
  // @@protoc_insertion_point(field_get:cmongoproto.CommandContainerReq.header)
  return header_ != NULL ? *header_
                         : *::cmongoproto::ReqHeader::internal_default_instance();
}
inline ::cmongoproto::ReqHeader* CommandContainerReq::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::cmongoproto::ReqHeader;
  }
  // @@protoc_insertion_point(field_mutable:cmongoproto.CommandContainerReq.header)
  return header_;
}
inline ::cmongoproto::ReqHeader* CommandContainerReq::release_header() {
  // @@protoc_insertion_point(field_release:cmongoproto.CommandContainerReq.header)
  
  ::cmongoproto::ReqHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void CommandContainerReq::set_allocated_header(::cmongoproto::ReqHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.CommandContainerReq.header)
}

// int32 container_id = 2;
inline void CommandContainerReq::clear_container_id() {
  container_id_ = 0;
}
inline ::google::protobuf::int32 CommandContainerReq::container_id() const {
  // @@protoc_insertion_point(field_get:cmongoproto.CommandContainerReq.container_id)
  return container_id_;
}
inline void CommandContainerReq::set_container_id(::google::protobuf::int32 value) {
  
  container_id_ = value;
  // @@protoc_insertion_point(field_set:cmongoproto.CommandContainerReq.container_id)
}

// string command = 3;
inline void CommandContainerReq::clear_command() {
  command_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CommandContainerReq::command() const {
  // @@protoc_insertion_point(field_get:cmongoproto.CommandContainerReq.command)
  return command_.GetNoArena();
}
inline void CommandContainerReq::set_command(const ::std::string& value) {
  
  command_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmongoproto.CommandContainerReq.command)
}
#if LANG_CXX11
inline void CommandContainerReq::set_command(::std::string&& value) {
  
  command_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmongoproto.CommandContainerReq.command)
}
#endif
inline void CommandContainerReq::set_command(const char* value) {
  
  command_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmongoproto.CommandContainerReq.command)
}
inline void CommandContainerReq::set_command(const char* value, size_t size) {
  
  command_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmongoproto.CommandContainerReq.command)
}
inline ::std::string* CommandContainerReq::mutable_command() {
  
  // @@protoc_insertion_point(field_mutable:cmongoproto.CommandContainerReq.command)
  return command_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CommandContainerReq::release_command() {
  // @@protoc_insertion_point(field_release:cmongoproto.CommandContainerReq.command)
  
  return command_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CommandContainerReq::set_allocated_command(::std::string* command) {
  if (command != NULL) {
    
  } else {
    
  }
  command_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), command);
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.CommandContainerReq.command)
}

// -------------------------------------------------------------------

// CommandContainerRes

// .cmongoproto.ResHeader header = 1;
inline bool CommandContainerRes::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void CommandContainerRes::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::cmongoproto::ResHeader& CommandContainerRes::header() const {
  // @@protoc_insertion_point(field_get:cmongoproto.CommandContainerRes.header)
  return header_ != NULL ? *header_
                         : *::cmongoproto::ResHeader::internal_default_instance();
}
inline ::cmongoproto::ResHeader* CommandContainerRes::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::cmongoproto::ResHeader;
  }
  // @@protoc_insertion_point(field_mutable:cmongoproto.CommandContainerRes.header)
  return header_;
}
inline ::cmongoproto::ResHeader* CommandContainerRes::release_header() {
  // @@protoc_insertion_point(field_release:cmongoproto.CommandContainerRes.header)
  
  ::cmongoproto::ResHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void CommandContainerRes::set_allocated_header(::cmongoproto::ResHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.CommandContainerRes.header)
}

// -------------------------------------------------------------------

// ResizeContainerReq

// .cmongoproto.ReqHeader header = 1;
inline bool ResizeContainerReq::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ResizeContainerReq::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::cmongoproto::ReqHeader& ResizeContainerReq::header() const {
  // @@protoc_insertion_point(field_get:cmongoproto.ResizeContainerReq.header)
  return header_ != NULL ? *header_
                         : *::cmongoproto::ReqHeader::internal_default_instance();
}
inline ::cmongoproto::ReqHeader* ResizeContainerReq::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::cmongoproto::ReqHeader;
  }
  // @@protoc_insertion_point(field_mutable:cmongoproto.ResizeContainerReq.header)
  return header_;
}
inline ::cmongoproto::ReqHeader* ResizeContainerReq::release_header() {
  // @@protoc_insertion_point(field_release:cmongoproto.ResizeContainerReq.header)
  
  ::cmongoproto::ReqHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void ResizeContainerReq::set_allocated_header(::cmongoproto::ReqHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.ResizeContainerReq.header)
}

// int32 container_id = 2;
inline void ResizeContainerReq::clear_container_id() {
  container_id_ = 0;
}
inline ::google::protobuf::int32 ResizeContainerReq::container_id() const {
  // @@protoc_insertion_point(field_get:cmongoproto.ResizeContainerReq.container_id)
  return container_id_;
}
inline void ResizeContainerReq::set_container_id(::google::protobuf::int32 value) {
  
  container_id_ = value;
  // @@protoc_insertion_point(field_set:cmongoproto.ResizeContainerReq.container_id)
}

// .cmongoproto.ResourceDesc quota = 3;
inline bool ResizeContainerReq::has_quota() const {
  return this != internal_default_instance() && quota_ != NULL;
}
inline void ResizeContainerReq::clear_quota() {
  if (GetArenaNoVirtual() == NULL && quota_ != NULL) delete quota_;
  quota_ = NULL;
}
inline const ::cmongoproto::ResourceDesc& ResizeContainerReq::quota() const {
  // @@protoc_insertion_point(field_get:cmongoproto.ResizeContainerReq.quota)
  return quota_ != NULL ? *quota_
                         : *::cmongoproto::ResourceDesc::internal_default_instance();
}
inline ::cmongoproto::ResourceDesc* ResizeContainerReq::mutable_quota() {
  
  if (quota_ == NULL) {
    quota_ = new ::cmongoproto::ResourceDesc;
  }
  // @@protoc_insertion_point(field_mutable:cmongoproto.ResizeContainerReq.quota)
  return quota_;
}
inline ::cmongoproto::ResourceDesc* ResizeContainerReq::release_quota() {
  // @@protoc_insertion_point(field_release:cmongoproto.ResizeContainerReq.quota)
  
  ::cmongoproto::ResourceDesc* temp = quota_;
  quota_ = NULL;
  return temp;
}
inline void ResizeContainerReq::set_allocated_quota(::cmongoproto::ResourceDesc* quota) {
  delete quota_;
  quota_ = quota;
  if (quota) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.ResizeContainerReq.quota)
}

// -------------------------------------------------------------------

// ResizeContainerRes

// .cmongoproto.ResHeader header = 1;
inline bool ResizeContainerRes::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ResizeContainerRes::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::cmongoproto::ResHeader& ResizeContainerRes::header() const {
  // @@protoc_insertion_point(field_get:cmongoproto.ResizeContainerRes.header)
  return header_ != NULL ? *header_
                         : *::cmongoproto::ResHeader::internal_default_instance();
}
inline ::cmongoproto::ResHeader* ResizeContainerRes::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::cmongoproto::ResHeader;
  }
  // @@protoc_insertion_point(field_mutable:cmongoproto.ResizeContainerRes.header)
  return header_;
}
inline ::cmongoproto::ResHeader* ResizeContainerRes::release_header() {
  // @@protoc_insertion_point(field_release:cmongoproto.ResizeContainerRes.header)
  
  ::cmongoproto::ResHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void ResizeContainerRes::set_allocated_header(::cmongoproto::ResHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.ResizeContainerRes.header)
}

// -------------------------------------------------------------------

// UpgradeContainerReq

// .cmongoproto.ReqHeader header = 1;
inline bool UpgradeContainerReq::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void UpgradeContainerReq::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::cmongoproto::ReqHeader& UpgradeContainerReq::header() const {
  // @@protoc_insertion_point(field_get:cmongoproto.UpgradeContainerReq.header)
  return header_ != NULL ? *header_
                         : *::cmongoproto::ReqHeader::internal_default_instance();
}
inline ::cmongoproto::ReqHeader* UpgradeContainerReq::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::cmongoproto::ReqHeader;
  }
  // @@protoc_insertion_point(field_mutable:cmongoproto.UpgradeContainerReq.header)
  return header_;
}
inline ::cmongoproto::ReqHeader* UpgradeContainerReq::release_header() {
  // @@protoc_insertion_point(field_release:cmongoproto.UpgradeContainerReq.header)
  
  ::cmongoproto::ReqHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void UpgradeContainerReq::set_allocated_header(::cmongoproto::ReqHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.UpgradeContainerReq.header)
}

// int32 container_id = 2;
inline void UpgradeContainerReq::clear_container_id() {
  container_id_ = 0;
}
inline ::google::protobuf::int32 UpgradeContainerReq::container_id() const {
  // @@protoc_insertion_point(field_get:cmongoproto.UpgradeContainerReq.container_id)
  return container_id_;
}
inline void UpgradeContainerReq::set_container_id(::google::protobuf::int32 value) {
  
  container_id_ = value;
  // @@protoc_insertion_point(field_set:cmongoproto.UpgradeContainerReq.container_id)
}

// string conf = 3;
inline void UpgradeContainerReq::clear_conf() {
  conf_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UpgradeContainerReq::conf() const {
  // @@protoc_insertion_point(field_get:cmongoproto.UpgradeContainerReq.conf)
  return conf_.GetNoArena();
}
inline void UpgradeContainerReq::set_conf(const ::std::string& value) {
  
  conf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmongoproto.UpgradeContainerReq.conf)
}
#if LANG_CXX11
inline void UpgradeContainerReq::set_conf(::std::string&& value) {
  
  conf_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmongoproto.UpgradeContainerReq.conf)
}
#endif
inline void UpgradeContainerReq::set_conf(const char* value) {
  
  conf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmongoproto.UpgradeContainerReq.conf)
}
inline void UpgradeContainerReq::set_conf(const char* value, size_t size) {
  
  conf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmongoproto.UpgradeContainerReq.conf)
}
inline ::std::string* UpgradeContainerReq::mutable_conf() {
  
  // @@protoc_insertion_point(field_mutable:cmongoproto.UpgradeContainerReq.conf)
  return conf_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UpgradeContainerReq::release_conf() {
  // @@protoc_insertion_point(field_release:cmongoproto.UpgradeContainerReq.conf)
  
  return conf_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UpgradeContainerReq::set_allocated_conf(::std::string* conf) {
  if (conf != NULL) {
    
  } else {
    
  }
  conf_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), conf);
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.UpgradeContainerReq.conf)
}

// -------------------------------------------------------------------

// UpgradeContainerRes

// .cmongoproto.ResHeader header = 1;
inline bool UpgradeContainerRes::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void UpgradeContainerRes::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::cmongoproto::ResHeader& UpgradeContainerRes::header() const {
  // @@protoc_insertion_point(field_get:cmongoproto.UpgradeContainerRes.header)
  return header_ != NULL ? *header_
                         : *::cmongoproto::ResHeader::internal_default_instance();
}
inline ::cmongoproto::ResHeader* UpgradeContainerRes::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::cmongoproto::ResHeader;
  }
  // @@protoc_insertion_point(field_mutable:cmongoproto.UpgradeContainerRes.header)
  return header_;
}
inline ::cmongoproto::ResHeader* UpgradeContainerRes::release_header() {
  // @@protoc_insertion_point(field_release:cmongoproto.UpgradeContainerRes.header)
  
  ::cmongoproto::ResHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void UpgradeContainerRes::set_allocated_header(::cmongoproto::ResHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.UpgradeContainerRes.header)
}

// -------------------------------------------------------------------

// UpdateContainerModuleReq

// .cmongoproto.ReqHeader header = 1;
inline bool UpdateContainerModuleReq::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void UpdateContainerModuleReq::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::cmongoproto::ReqHeader& UpdateContainerModuleReq::header() const {
  // @@protoc_insertion_point(field_get:cmongoproto.UpdateContainerModuleReq.header)
  return header_ != NULL ? *header_
                         : *::cmongoproto::ReqHeader::internal_default_instance();
}
inline ::cmongoproto::ReqHeader* UpdateContainerModuleReq::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::cmongoproto::ReqHeader;
  }
  // @@protoc_insertion_point(field_mutable:cmongoproto.UpdateContainerModuleReq.header)
  return header_;
}
inline ::cmongoproto::ReqHeader* UpdateContainerModuleReq::release_header() {
  // @@protoc_insertion_point(field_release:cmongoproto.UpdateContainerModuleReq.header)
  
  ::cmongoproto::ReqHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void UpdateContainerModuleReq::set_allocated_header(::cmongoproto::ReqHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.UpdateContainerModuleReq.header)
}

// int32 container_id = 2;
inline void UpdateContainerModuleReq::clear_container_id() {
  container_id_ = 0;
}
inline ::google::protobuf::int32 UpdateContainerModuleReq::container_id() const {
  // @@protoc_insertion_point(field_get:cmongoproto.UpdateContainerModuleReq.container_id)
  return container_id_;
}
inline void UpdateContainerModuleReq::set_container_id(::google::protobuf::int32 value) {
  
  container_id_ = value;
  // @@protoc_insertion_point(field_set:cmongoproto.UpdateContainerModuleReq.container_id)
}

// .cmongoproto.MongoType ctype = 3;
inline void UpdateContainerModuleReq::clear_ctype() {
  ctype_ = 0;
}
inline ::cmongoproto::MongoType UpdateContainerModuleReq::ctype() const {
  // @@protoc_insertion_point(field_get:cmongoproto.UpdateContainerModuleReq.ctype)
  return static_cast< ::cmongoproto::MongoType >(ctype_);
}
inline void UpdateContainerModuleReq::set_ctype(::cmongoproto::MongoType value) {
  
  ctype_ = value;
  // @@protoc_insertion_point(field_set:cmongoproto.UpdateContainerModuleReq.ctype)
}

// string module_version = 4;
inline void UpdateContainerModuleReq::clear_module_version() {
  module_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UpdateContainerModuleReq::module_version() const {
  // @@protoc_insertion_point(field_get:cmongoproto.UpdateContainerModuleReq.module_version)
  return module_version_.GetNoArena();
}
inline void UpdateContainerModuleReq::set_module_version(const ::std::string& value) {
  
  module_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmongoproto.UpdateContainerModuleReq.module_version)
}
#if LANG_CXX11
inline void UpdateContainerModuleReq::set_module_version(::std::string&& value) {
  
  module_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmongoproto.UpdateContainerModuleReq.module_version)
}
#endif
inline void UpdateContainerModuleReq::set_module_version(const char* value) {
  
  module_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmongoproto.UpdateContainerModuleReq.module_version)
}
inline void UpdateContainerModuleReq::set_module_version(const char* value, size_t size) {
  
  module_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmongoproto.UpdateContainerModuleReq.module_version)
}
inline ::std::string* UpdateContainerModuleReq::mutable_module_version() {
  
  // @@protoc_insertion_point(field_mutable:cmongoproto.UpdateContainerModuleReq.module_version)
  return module_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UpdateContainerModuleReq::release_module_version() {
  // @@protoc_insertion_point(field_release:cmongoproto.UpdateContainerModuleReq.module_version)
  
  return module_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UpdateContainerModuleReq::set_allocated_module_version(::std::string* module_version) {
  if (module_version != NULL) {
    
  } else {
    
  }
  module_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), module_version);
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.UpdateContainerModuleReq.module_version)
}

// int32 restart = 5;
inline void UpdateContainerModuleReq::clear_restart() {
  restart_ = 0;
}
inline ::google::protobuf::int32 UpdateContainerModuleReq::restart() const {
  // @@protoc_insertion_point(field_get:cmongoproto.UpdateContainerModuleReq.restart)
  return restart_;
}
inline void UpdateContainerModuleReq::set_restart(::google::protobuf::int32 value) {
  
  restart_ = value;
  // @@protoc_insertion_point(field_set:cmongoproto.UpdateContainerModuleReq.restart)
}

// string package_url = 6;
inline void UpdateContainerModuleReq::clear_package_url() {
  package_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UpdateContainerModuleReq::package_url() const {
  // @@protoc_insertion_point(field_get:cmongoproto.UpdateContainerModuleReq.package_url)
  return package_url_.GetNoArena();
}
inline void UpdateContainerModuleReq::set_package_url(const ::std::string& value) {
  
  package_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmongoproto.UpdateContainerModuleReq.package_url)
}
#if LANG_CXX11
inline void UpdateContainerModuleReq::set_package_url(::std::string&& value) {
  
  package_url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmongoproto.UpdateContainerModuleReq.package_url)
}
#endif
inline void UpdateContainerModuleReq::set_package_url(const char* value) {
  
  package_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmongoproto.UpdateContainerModuleReq.package_url)
}
inline void UpdateContainerModuleReq::set_package_url(const char* value, size_t size) {
  
  package_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmongoproto.UpdateContainerModuleReq.package_url)
}
inline ::std::string* UpdateContainerModuleReq::mutable_package_url() {
  
  // @@protoc_insertion_point(field_mutable:cmongoproto.UpdateContainerModuleReq.package_url)
  return package_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UpdateContainerModuleReq::release_package_url() {
  // @@protoc_insertion_point(field_release:cmongoproto.UpdateContainerModuleReq.package_url)
  
  return package_url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UpdateContainerModuleReq::set_allocated_package_url(::std::string* package_url) {
  if (package_url != NULL) {
    
  } else {
    
  }
  package_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), package_url);
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.UpdateContainerModuleReq.package_url)
}

// string user_password = 7;
inline void UpdateContainerModuleReq::clear_user_password() {
  user_password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UpdateContainerModuleReq::user_password() const {
  // @@protoc_insertion_point(field_get:cmongoproto.UpdateContainerModuleReq.user_password)
  return user_password_.GetNoArena();
}
inline void UpdateContainerModuleReq::set_user_password(const ::std::string& value) {
  
  user_password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cmongoproto.UpdateContainerModuleReq.user_password)
}
#if LANG_CXX11
inline void UpdateContainerModuleReq::set_user_password(::std::string&& value) {
  
  user_password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cmongoproto.UpdateContainerModuleReq.user_password)
}
#endif
inline void UpdateContainerModuleReq::set_user_password(const char* value) {
  
  user_password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cmongoproto.UpdateContainerModuleReq.user_password)
}
inline void UpdateContainerModuleReq::set_user_password(const char* value, size_t size) {
  
  user_password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cmongoproto.UpdateContainerModuleReq.user_password)
}
inline ::std::string* UpdateContainerModuleReq::mutable_user_password() {
  
  // @@protoc_insertion_point(field_mutable:cmongoproto.UpdateContainerModuleReq.user_password)
  return user_password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UpdateContainerModuleReq::release_user_password() {
  // @@protoc_insertion_point(field_release:cmongoproto.UpdateContainerModuleReq.user_password)
  
  return user_password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UpdateContainerModuleReq::set_allocated_user_password(::std::string* user_password) {
  if (user_password != NULL) {
    
  } else {
    
  }
  user_password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_password);
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.UpdateContainerModuleReq.user_password)
}

// -------------------------------------------------------------------

// UpdateContainerModuleRes

// .cmongoproto.ResHeader header = 1;
inline bool UpdateContainerModuleRes::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void UpdateContainerModuleRes::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::cmongoproto::ResHeader& UpdateContainerModuleRes::header() const {
  // @@protoc_insertion_point(field_get:cmongoproto.UpdateContainerModuleRes.header)
  return header_ != NULL ? *header_
                         : *::cmongoproto::ResHeader::internal_default_instance();
}
inline ::cmongoproto::ResHeader* UpdateContainerModuleRes::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::cmongoproto::ResHeader;
  }
  // @@protoc_insertion_point(field_mutable:cmongoproto.UpdateContainerModuleRes.header)
  return header_;
}
inline ::cmongoproto::ResHeader* UpdateContainerModuleRes::release_header() {
  // @@protoc_insertion_point(field_release:cmongoproto.UpdateContainerModuleRes.header)
  
  ::cmongoproto::ResHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void UpdateContainerModuleRes::set_allocated_header(::cmongoproto::ResHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:cmongoproto.UpdateContainerModuleRes.header)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace cmongoproto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::cmongoproto::MongoVersion> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cmongoproto::MongoVersion>() {
  return ::cmongoproto::MongoVersion_descriptor();
}
template <> struct is_proto_enum< ::cmongoproto::MongoType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cmongoproto::MongoType>() {
  return ::cmongoproto::MongoType_descriptor();
}
template <> struct is_proto_enum< ::cmongoproto::MemberType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cmongoproto::MemberType>() {
  return ::cmongoproto::MemberType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_cmongo_2fcmongoproto_2fcmongo_2eproto__INCLUDED
